#!/usr/bin/env python3
"""
Financial Plan Generator (NL) - CLI

Fish-friendly examples:
  # fish
  cd /home/vince/Projects/llama-orch/.business/financieelplan_NL_nl
  chmod +x fp
  ./fp scan --roots ../ondernemersplan_NL_nl/.002-draft ../.specs ../frontend ../consumers --out ./out
  ./fp run ./examples/voorbeeld.yml --out ./out --months 12 --scenario base --vat-period monthly

Constraints:
- Work only inside this folder. Pure stdlib + decimal.
- Deterministic Decimal context ROUND_HALF_UP.
- Read-only scan; no code imports outside this folder.
- YAML optional: will use PyYAML if available; otherwise accept JSON.

Outputs:
- 00_overview.md
- 10_investering_financiering.md + 10_investering.csv + 10_financiering.csv
- 20_liquiditeit.md + 20_liquiditeit_monthly.csv
- 30_exploitatie.md + 30_exploitatie.csv
- 40_qredits_maandlasten.md + 40_amortisatie.csv
- 50_belastingen.md + 50_tax.csv
- zz_schema.md

Disclaimer: Indicatieve berekeningen, geen fiscale advisering.
"""
from __future__ import annotations

import argparse
import csv
import datetime as dt
import json
import math
import os
import re
import sys
from decimal import Decimal, getcontext, ROUND_HALF_UP
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# Optional YAML support (PyYAML if present). No hard dependency.
try:
    import yaml  # type: ignore
except Exception:  # pragma: no cover
    yaml = None  # type: ignore

# Deterministic Decimal context
CTX = getcontext()
CTX.prec = 28
CTX.rounding = ROUND_HALF_UP

D = Decimal
CENT = D('0.01')
HUNDRED = D('100')
ZERO = D('0')

# ----------------------------
# Utilities
# ----------------------------

def money(x: Decimal) -> str:
    x = D(x).quantize(CENT)
    neg = x < 0
    x = -x if neg else x
    s = f"{x:.2f}"
    integer, dec = s.split('.')
    groups = []
    while integer:
        groups.append(integer[-3:])
        integer = integer[:-3]
    res = '€ ' + '.'.join(groups[::-1]) + ',' + dec
    return ('-' + res) if neg else res


def pct_from_ratio(r: Decimal) -> str:
    return f"{(r * HUNDRED).quantize(CENT)}%"


def month_str(d: dt.date) -> str:
    return f"{d.year:04d}-{d.month:02d}"


def parse_month(s: str) -> dt.date:
    y, m = s.split('-')
    return dt.date(int(y), int(m), 1)


def add_months(d: dt.date, n: int) -> dt.date:
    y = d.year + (d.month - 1 + n) // 12
    m = (d.month - 1 + n) % 12 + 1
    return dt.date(y, m, 1)


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def write_csv(path: Path, header: List[str], rows: List[List[Any]]) -> None:
    ensure_dir(path.parent)
    with path.open('w', newline='', encoding='utf-8') as f:
        w = csv.writer(f)
        w.writerow(header)
        for r in rows:
            w.writerow(r)


def write_text(path: Path, text: str) -> None:
    ensure_dir(path.parent)
    path.write_text(text, encoding='utf-8')


def decimalize(n: Any) -> Decimal:
    if isinstance(n, Decimal):
        return n
    return D(str(n))


def validate_nonneg(name: str, value: Decimal) -> None:
    if value < 0:
        raise ValueError(f"{name} mag niet negatief zijn: {value}")


# ----------------------------
# Scanner (Context Index)
# ----------------------------
DOMAIN_TERMS = [
    'omzet', 'cogs', 'marge', 'opex', 'huur', 'marketing', 'salarissen',
    'verzekeringen', 'ict', 'overig', 'dso', 'dpo', 'btw', 'kor',
    'urencriterium', 'ib', 'vpb', 'qredits', 'amortisatie', 'afschrijving',
    'liquiditeit', 'exploitatie', 'seizoen', 'krediet', 'lening', 'hoofdsom',
    'rente', 'grace', 'aflossing'
]

TEXT_EXTS = {'.md', '.mdx', '.txt', '.yaml', '.yml', '.json'}
SECRETS_RE = re.compile(r"(BEGIN (RSA|EC|OPENSSH) PRIVATE KEY|api[_-]?key|secret|token)", re.I)


def _extract_snippets(txt: str, term: str, max_snips: int = 2, span: int = 200) -> List[str]:
    ltxt = txt.lower()
    res: List[str] = []
    start = 0
    while len(res) < max_snips:
        idx = ltxt.find(term, start)
        if idx == -1:
            break
        a = max(0, idx - span // 2)
        b = min(len(txt), idx + span // 2)
        snip = txt[a:b]
        snip = snip.replace('\n', ' ').replace('\r', ' ')
        snip = re.sub(r"\s+", " ", snip).strip()
        res.append(snip)
        start = idx + len(term)
    return res


def scan_roots(roots: List[Path], out_dir: Path) -> None:
    files_meta: List[Dict[str, Any]] = []
    term_counts: Dict[str, int] = {t: 0 for t in DOMAIN_TERMS}
    snippets: Dict[str, List[str]] = {t: [] for t in DOMAIN_TERMS}

    for root in roots:
        if not root.exists():
            continue
        for dirpath, _, filenames in os.walk(root):
            for fn in filenames:
                p = Path(dirpath) / fn
                if p.suffix.lower() not in TEXT_EXTS:
                    continue
                try:
                    st = p.stat()
                except Exception:
                    continue
                if st.st_size > 2 * 1024 * 1024:  # 2MB
                    continue
                try:
                    txt = p.read_text(encoding='utf-8', errors='ignore')
                except Exception:
                    continue
                if SECRETS_RE.search(txt):
                    continue
                files_meta.append({
                    'path': str(p.resolve()),
                    'relpath': str(p),
                    'size': st.st_size,
                    'mtime': int(st.st_mtime),
                })
                ltxt = txt.lower()
                for t in DOMAIN_TERMS:
                    c = ltxt.count(t)
                    if c > 0:
                        term_counts[t] += c
                        if len(snippets[t]) < 2:
                            snippets[t].extend(_extract_snippets(txt, t))
                            snippets[t] = snippets[t][:2]

    # select top 20 terms
    top_terms = sorted(term_counts.items(), key=lambda kv: kv[1], reverse=True)[:20]
    top_terms_dict = {k: v for k, v in top_terms if v > 0}
    top_snippets = {k: snippets[k] for k in top_terms_dict.keys()}

    out = {
        'files': files_meta,
        'terms': term_counts,
        'top_terms': top_terms_dict,
        'snippets': top_snippets,
    }
    ensure_dir(out_dir)
    write_text(out_dir / 'context_index.json', json.dumps(out, indent=2, ensure_ascii=False))


# ----------------------------
# Core financial model
# ----------------------------

def load_input(path: Path) -> Dict[str, Any]:
    text = path.read_text(encoding='utf-8')
    if path.suffix.lower() in ('.yml', '.yaml') and yaml is not None:
        data = yaml.safe_load(text)
    else:
        data = json.loads(text)
    if not isinstance(data, dict):
        raise ValueError('Top-level config must be a mapping')
    return data


def apply_scenario(base: Dict[str, Any], scenario: str) -> Dict[str, Any]:
    d = json.loads(json.dumps(base))  # deep copy via json
    if scenario == 'base':
        return d
    delta = base.get('scenario_delta', {}).get(scenario, {})
    # omzet_pm_pct, cogs_pct, opex_pm_pct in perc points
    om = d.get('omzetmodel', {})
    if 'omzet_pm_pct' in delta:
        om['omzet_pm'] = float(D(str(om.get('omzet_pm', 0))) * (D('1') + D(str(delta['omzet_pm_pct'])) / HUNDRED))
    if 'cogs_pct' in delta:
        om['cogs_pct'] = float(D(str(om.get('cogs_pct', 0))) + D(str(delta['cogs_pct'])))
    if 'opex_pm_pct' in delta:
        opex = om.get('opex_pm', {})
        new_opex = {}
        for k, v in opex.items():
            new_opex[k] = float(D(str(v)) * (D('1') + D(str(delta['opex_pm_pct'])) / HUNDRED))
        om['opex_pm'] = new_opex
    d['omzetmodel'] = om
    return d


def months_range(start: dt.date, n: int) -> List[dt.date]:
    return [add_months(start, i) for i in range(n)]


def season_factor(season: Dict[str, Any], ym: str, key_suffix: str) -> Decimal:
    # season like { '2025-12': {'omzet_pm_pct': +30} }
    m = season.get(ym, {})
    pct = D(str(m.get(key_suffix, 0)))
    return D('1') + (pct / HUNDRED)


def build_depreciation(investeringen: List[Dict[str, Any]], start_maand: dt.date, months: List[dt.date]) -> Tuple[Dict[str, Decimal], List[Dict[str, Any]], Decimal]:
    dep_per_month: Dict[str, Decimal] = {month_str(m): ZERO for m in months}
    items_out: List[Dict[str, Any]] = []
    total_invest = ZERO
    for it in investeringen or []:
        bedrag = decimalize(it['bedrag'])
        validate_nonneg('investering.bedrag', bedrag)
        total_invest += bedrag
        life = int(it['levensduur_mnd'])
        if life <= 0:
            raise ValueError('levensduur_mnd moet > 0')
        start_s = it.get('start_maand') or month_str(start_maand)
        start_i = parse_month(start_s)
        monthly = (bedrag / D(str(life))).quantize(CENT)
        items_out.append({
            'omschrijving': it['omschrijving'],
            'bedrag': float(bedrag),
            'levensduur_mnd': life,
            'start_maand': start_s,
            'afschrijving_pm': float(monthly),
        })
        for m in months:
            if m >= start_i and (m < add_months(start_i, life)):
                dep_per_month[month_str(m)] += monthly
    return dep_per_month, items_out, total_invest


def annuity_payment(P: Decimal, r: Decimal, n: int) -> Decimal:
    if n <= 0:
        return ZERO
    if r == 0:
        return (P / D(str(n))).quantize(CENT)
    denom = D('1') - (D('1') + r) ** D(str(-n))
    A = (P * r) / denom
    return A.quantize(CENT)


def build_amortization(loans: List[Dict[str, Any]], months: List[dt.date]) -> Tuple[List[Dict[str, Any]], Dict[str, Decimal], Dict[str, Decimal]]:
    schedule_rows: List[Dict[str, Any]] = []
    interest_pm: Dict[str, Decimal] = {month_str(m): ZERO for m in months}
    principal_pm: Dict[str, Decimal] = {month_str(m): ZERO for m in months}

    for ln in loans or []:
        P = decimalize(ln['hoofdsom'])
        validate_nonneg('lening.hoofdsom', P)
        r_year = decimalize(ln['rente_nominaal_jr_pct']) / HUNDRED
        r = (r_year / D('12')).quantize(D('0.0000001'))
        N = int(ln['looptijd_mnd'])
        grace = int(ln.get('grace_mnd', 0) or 0)
        only_interest = bool(ln.get('alleen_rente_in_grace', False))
        verstrekker = ln.get('verstrekker', 'Onbekend')

        balance = P
        # interest-only months
        for i in range(min(grace, len(months))):
            ym = month_str(months[i])
            interest = (balance * r).quantize(CENT)
            principal = ZERO if only_interest else annuity_payment(P, r, N) - interest
            principal = principal.quantize(CENT)
            balance = (balance - principal).quantize(CENT)
            interest_pm[ym] += interest
            principal_pm[ym] += principal
            schedule_rows.append({
                'maand': ym, 'verstrekker': verstrekker,
                'rente_pm': float(interest), 'aflossing_pm': float(principal), 'restschuld': float(balance)
            })
        # amortizing months
        remaining = max(0, N - grace)
        A = annuity_payment(balance, r, remaining) if remaining > 0 else ZERO
        for i in range(grace, min(N, len(months))):
            ym = month_str(months[i])
            interest = (balance * r).quantize(CENT)
            principal = (A - interest).quantize(CENT)
            # last payment adjust rounding
            if i == N - 1 or i == len(months) - 1:
                principal = min(principal, balance)
            balance = (balance - principal).quantize(CENT)
            interest_pm[ym] += interest
            principal_pm[ym] += principal
            schedule_rows.append({
                'maand': ym, 'verstrekker': verstrekker,
                'rente_pm': float(interest), 'aflossing_pm': float(principal), 'restschuld': float(balance)
            })
    return schedule_rows, interest_pm, principal_pm


def compute_model(cfg: Dict[str, Any], months_count: int, scenario: str, vat_period_flag: Optional[str]) -> Dict[str, Any]:
    bedrijf = cfg['bedrijf']
    start_maand = parse_month(bedrijf['start_maand'])
    months = months_range(start_maand, months_count)
    ym_list = [month_str(m) for m in months]

    cfg_s = apply_scenario(cfg, scenario)

    inv = cfg_s.get('investeringen', [])
    dep_per_month, inv_items, total_invest = build_depreciation(inv, start_maand, months)

    fin = cfg_s.get('financiering', {})
    eigen_inbreng = decimalize(fin.get('eigen_inbreng', 0))
    loans = fin.get('leningen', [])
    amort_rows, interest_pm, principal_pm = build_amortization(loans, months)

    om = cfg_s.get('omzetmodel', {})
    omzet_pm = decimalize(om.get('omzet_pm', 0))
    cogs_pct = decimalize(om.get('cogs_pct', 0)) / HUNDRED
    opex_map = {k: decimalize(v) for k, v in (om.get('opex_pm', {}) or {}).items()}
    dso_days = int(om.get('dso_dagen', 30))
    dpo_days = int(om.get('dpo_dagen', 14))
    season = om.get('seizoen', {}) or {}

    # Revenue and costs (accrual)
    revenue: Dict[str, Decimal] = {}
    cogs: Dict[str, Decimal] = {}
    opex_lines: Dict[str, Dict[str, Decimal]] = {k: {} for k in opex_map.keys()}
    opex_total: Dict[str, Decimal] = {}

    for i, m in enumerate(months):
        ym = ym_list[i]
        rf = season_factor(season, ym, 'omzet_pm_pct')
        of = season_factor(season, ym, 'opex_pm_pct')
        rev = (omzet_pm * rf).quantize(CENT)
        revenue[ym] = rev
        c = (rev * cogs_pct).quantize(CENT)
        cogs[ym] = c
        ot = ZERO
        for k, base_v in opex_map.items():
            v = (base_v * of).quantize(CENT)
            opex_lines[k][ym] = v
            ot += v
        opex_total[ym] = ot

    # DSO/DPO shifts
    def months_shift(days: int) -> int:
        if days <= 0:
            return 0
        return max(0, int((days + 15) // 30))

    dso = months_shift(dso_days)
    dpo = months_shift(dpo_days)

    cash_in_revenue: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}
    cash_out_cogs: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}

    for i, ym in enumerate(ym_list):
        # revenue cash later
        j = i + dso
        if j < len(ym_list):
            cash_in_revenue[ym_list[j]] += revenue[ym]
        # cogs paid later
        j2 = i + dpo
        if j2 < len(ym_list):
            cash_out_cogs[ym_list[j2]] += cogs[ym]

    # VAT
    bel = cfg_s.get('belastingen', {})
    btw_pct = decimalize(bel.get('btw_pct', 21)) / HUNDRED
    btw_vrij = bool(bel.get('btw_vrij', False))
    kor = bool(bel.get('kor', False))
    vat_model = bel.get('btw_model', 'omzet_enkel')
    vat_period = vat_period_flag or bel.get('vat_period', 'monthly')

    vat_accrual: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}
    if not (btw_vrij or kor):
        if vat_model == 'omzet_enkel':
            for ym in ym_list:
                vat_accrual[ym] = (revenue[ym] * btw_pct).quantize(CENT)
        else:
            # omzet_minus_simple_kosten – subtract VAT on opex types we know (simplified)
            for ym in ym_list:
                base = (revenue[ym] * btw_pct)
                # assume all opex subject to same rate for simplicity
                input_vat = (opex_total[ym] * btw_pct)
                vat_accrual[ym] = (base - input_vat).quantize(CENT)

    vat_payment: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}
    if not (btw_vrij or kor):
        if vat_period == 'monthly':
            for ym in ym_list:
                vat_payment[ym] = vat_accrual[ym]
        else:  # quarterly
            # group months by calendar quarter and pay in quarter's last month
            by_q: Dict[Tuple[int, int], List[Tuple[str, Decimal]]] = {}
            for m in months:
                q = (m.year, (m.month - 1) // 3 + 1)
                by_q.setdefault(q, []).append((month_str(m), vat_accrual[month_str(m)]))
            for (y, q), items in by_q.items():
                acc = sum((v for _, v in items), ZERO)
                last_ym = items[-1][0]
                vat_payment[last_ym] = acc

    # Liquidity and P&L assembly
    dep = dep_per_month
    interest = interest_pm
    principal = principal_pm

    cash_begin: Dict[str, Decimal] = {}
    cash_end: Dict[str, Decimal] = {}

    inflow_other: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}
    outflow_other: Dict[str, Decimal] = {ym: ZERO for ym in ym_list}

    # month 1 injections
    if ym_list:
        inflow_other[ym_list[0]] += eigen_inbreng
        for ln in loans or []:
            inflow_other[ym_list[0]] += decimalize(ln['hoofdsom'])

    # build opex cash (paid in month, no shift)
    opex_cash: Dict[str, Decimal] = {ym: opex_total[ym] for ym in ym_list}

    # compute cash schedule
    prev_end = ZERO
    lowest_cash = None
    lowest_cash_month = None
    for ym in ym_list:
        cash_begin[ym] = prev_end
        inflow = cash_in_revenue[ym] + inflow_other[ym]
        outflow = cash_out_cogs[ym] + opex_cash[ym] + vat_payment[ym] + interest[ym] + principal[ym]
        end = (cash_begin[ym] + inflow - outflow).quantize(CENT)
        cash_end[ym] = end
        prev_end = end
        if lowest_cash is None or end < lowest_cash:
            lowest_cash = end
            lowest_cash_month = ym

    # P&L
    pnl_rows: List[Dict[str, Any]] = []
    for ym in ym_list:
        marge = (revenue[ym] - cogs[ym]).quantize(CENT)
        ebitda = (marge - opex_total[ym]).quantize(CENT)
        ebit = (ebitda - dep[ym]).quantize(CENT)
        ebt = (ebit - interest[ym]).quantize(CENT)
        pnl_rows.append({
            'maand': ym,
            'omzet': float(revenue[ym]),
            'cogs': float(cogs[ym]),
            'marge': float(marge),
            'opex': float(opex_total[ym]),
            'afschrijving': float(dep[ym]),
            'rente': float(interest[ym]),
            'resultaat_vb': float(ebt)
        })

    # coverage: average EBITDA / average debt service
    avg_ebitda = sum((D(str(r['marge'])) - D(str(r['opex'])) for r in pnl_rows), ZERO) / D(str(len(pnl_rows))) if pnl_rows else ZERO
    avg_debt_service = sum((interest[ym] + principal[ym] for ym in ym_list), ZERO) / D(str(len(ym_list))) if ym_list else ZERO
    coverage = (avg_ebitda / avg_debt_service) if avg_debt_service != 0 else D('0')

    return {
        'months': ym_list,
        'revenue': revenue,
        'cogs': cogs,
        'opex_lines': opex_lines,
        'opex_total': opex_total,
        'depreciation': dep,
        'interest': interest,
        'principal': principal,
        'cash_begin': cash_begin,
        'cash_end': cash_end,
        'cash_in_revenue': cash_in_revenue,
        'cash_out_cogs': cash_out_cogs,
        'inflow_other': inflow_other,
        'vat_payment': vat_payment,
        'amort_rows': amort_rows,
        'invest_items': inv_items,
        'total_invest': total_invest,
        'eigen_inbreng': eigen_inbreng,
        'lowest_cash': lowest_cash or ZERO,
        'lowest_cash_month': lowest_cash_month,
        'avg_ebitda': avg_ebitda.quantize(CENT),
        'avg_debt_service': avg_debt_service.quantize(CENT),
        'coverage': coverage,
        'config': cfg_s,
    }


# ----------------------------
# Reporting
# ----------------------------

def load_context_snippets(out_dir: Path) -> Dict[str, Any]:
    ctx_path = out_dir / 'meta' / 'context_index.json'
    if ctx_path.exists():
        try:
            return json.loads(ctx_path.read_text(encoding='utf-8'))
        except Exception:
            return {}
    return {}


def overview_md(model: Dict[str, Any], ctx: Dict[str, Any]) -> str:
    months = model['months']
    first_cash = (model['eigen_inbreng'] + sum((decimalize(ln['hoofdsom']) for ln in model['config'].get('financiering', {}).get('leningen', []) or []), ZERO)).quantize(CENT) if months else ZERO
    lowest_cash = model['lowest_cash']
    lowest_cash_month = model['lowest_cash_month'] or (months[0] if months else '')
    coverage = model['coverage']

    bel = model['config'].get('belastingen', {})
    vat_model = bel.get('btw_model', 'omzet_enkel')
    regime = bel.get('regime', 'IB')

    # context line
    ctx_terms = ctx.get('top_terms', {})
    ctx_para = ''
    if ctx_terms:
        key = next(iter(ctx_terms.keys()))
        snips = ctx.get('snippets', {}).get(key, [])
        if snips:
            ctx_para = f"\n> Context uit repo (term: {key}): {snips[0]}\n"

    return (
        f"# Overzicht\n\n"
        f"- Start kas (eigen inbreng + leningen in maand 1): {money(first_cash)}\n"
        f"- Laagste kasstand: {money(lowest_cash)} (maand {lowest_cash_month})\n"
        f"- Maandlast-dekking (gem. EBITDA / gem. schuldendienst): {(coverage.quantize(D('0.01')) if isinstance(coverage, Decimal) else D(str(coverage)).quantize(D('0.01')))}x\n"
        f"- Belastingregime: {regime}, BTW-model: {vat_model}\n"
        f"\n{ctx_para}\n"
        f"_Indicatief; geen fiscale advisering._\n"
    )


def inv_fin_md(model: Dict[str, Any]) -> str:
    total_invest = model['total_invest']
    eigen = model['eigen_inbreng']
    debt = sum((decimalize(ln['hoofdsom']) for ln in model['config'].get('financiering', {}).get('leningen', []) or []), ZERO)
    debt_pct = (debt / (eigen + debt) * HUNDRED) if (eigen + debt) > 0 else ZERO
    equity_pct = HUNDRED - debt_pct if (eigen + debt) > 0 else ZERO
    return (
        f"# Investeringen & Financiering\n\n"
        f"- Totale investering: {money(total_invest)}\n"
        f"- Eigen inbreng: {money(eigen)}\n"
        f"- Vreemd vermogen: {money(debt)}\n"
        f"- Debt/Equity: {pct_from_ratio(debt_pct / HUNDRED)} / {pct_from_ratio(equity_pct / HUNDRED)}\n"
    )


def exploitatie_md(model: Dict[str, Any]) -> str:
    return (
        f"# Exploitatie (maandelijks)\n\n"
        f"Toelichting: omzet → COGS → marge → OPEX → afschrijving → rente → resultaat (v/bel).\n"
    )


def liquiditeit_md(model: Dict[str, Any]) -> str:
    return (
        f"# Liquiditeit\n\n"
        f"Kasstroomtabel met DSO/DPO verschuivingen en BTW-afdracht per periode.\n"
    )


def qredits_md(model: Dict[str, Any]) -> str:
    return (
        f"# Qredits / Maandlasten\n\n"
        f"Volledig aflosschema; beoordeling van maandlast-dekking in Overzicht.\n"
    )


def tax_md(model: Dict[str, Any]) -> str:
    bel = model['config'].get('belastingen', {})
    regime = bel.get('regime', 'IB')
    kor = bool(bel.get('kor', False))
    btw_vrij = bool(bel.get('btw_vrij', False))
    btw_note = 'Geen BTW-afdracht (KOR of vrijgesteld).' if (kor or btw_vrij) else 'BTW volgens gekozen model.'
    return (
        f"# Belastingen (indicatief)\n\n"
        f"Regime: {regime}. {btw_note} Geen fiscale advisering.\n"
    )


def schema_md() -> str:
    return (
        "# Schema (mapping input → output)\n\n"
        "- bedrijf.start_maand → tijdlijn (maanden)\n"
        "- investeringen[*] → afschrijving per maand; 10_investering.csv\n"
        "- financiering.{eigen_inbreng,leningen[*]} → kasinstroom m1; 40_amortisatie.csv\n"
        "- omzetmodel.{omzet_pm,cogs_pct,opex_pm,*} → exploitatie & liquiditeit\n"
        "- belastingen.{btw_pct,btw_vrij,kor,btw_model,vat_period} → BTW-afdracht\n"
    )


def write_reports(out_dir: Path, model: Dict[str, Any]) -> None:
    ctx = load_context_snippets(out_dir)

    # 00_overview.md
    write_text(out_dir / '00_overview.md', overview_md(model, ctx))

    # 10_investering_financiering.md + CSVs
    write_text(out_dir / '10_investering_financiering.md', inv_fin_md(model))
    inv_rows = [[it['omschrijving'], f"{it['levensduur_mnd']}", f"{it['start_maand']}", f"{Decimal(str(it['afschrijving_pm'])).quantize(CENT)}", f"{Decimal(str(it['bedrag'])).quantize(CENT)}"] for it in model['invest_items']]
    write_csv(out_dir / '10_investering.csv', ['omschrijving','levensduur_mnd','start_maand','afschrijving_pm','bedrag'], inv_rows)
    fin_rows = []
    fin = model['config'].get('financiering', {})
    fin_rows.append(['eigen_inbreng', f"{model['eigen_inbreng'].quantize(CENT)}"])
    for ln in fin.get('leningen', []) or []:
        fin_rows.append([ln.get('verstrekker','Onbekend'), f"{Decimal(str(ln['hoofdsom'])).quantize(CENT)}", f"{ln.get('rente_nominaal_jr_pct')}%", ln.get('looptijd_mnd'), ln.get('grace_mnd',0)])
    write_csv(out_dir / '10_financiering.csv', ['bron','bedrag','rente_nominaal_jr_pct','looptijd_mnd','grace_mnd'], fin_rows)

    # 20_liquiditeit.md + CSV
    write_text(out_dir / '20_liquiditeit.md', liquiditeit_md(model))
    liq_rows = []
    for ym in model['months']:
        liq_rows.append([
            ym,
            f"{model['cash_begin'][ym].quantize(CENT)}",
            f"{model['cash_in_revenue'][ym].quantize(CENT)}",
            f"{model['inflow_other'][ym].quantize(CENT)}",
            f"{model['cash_out_cogs'][ym].quantize(CENT)}",
            f"{model['opex_total'][ym].quantize(CENT)}",
            f"{model['vat_payment'][ym].quantize(CENT)}",
            f"{model['interest'][ym].quantize(CENT)}",
            f"{model['principal'][ym].quantize(CENT)}",
            f"{model['cash_end'][ym].quantize(CENT)}",
        ])
    write_csv(out_dir / '20_liquiditeit_monthly.csv', ['maand','begin_kas','in_omzet','in_overig','uit_cogs','uit_opex','uit_btw','uit_rente','uit_aflossing','eind_kas'], liq_rows)

    # 30_exploitatie.md + CSV
    write_text(out_dir / '30_exploitatie.md', exploitatie_md(model))
    # Include OPEX per category columns
    opex_keys = sorted(list(model.get('opex_lines', {}).keys()))
    exp_header = ['maand', 'omzet', 'cogs', 'marge'] + [f"opex_{k}" for k in opex_keys] + ['opex_totaal', 'afschrijving', 'rente', 'resultaat_vb']
    exp_rows = []
    for ym in model['months']:
        row = [
            ym,
            f"{model['revenue'][ym].quantize(CENT)}",
            f"{model['cogs'][ym].quantize(CENT)}",
            f"{(model['revenue'][ym]-model['cogs'][ym]).quantize(CENT)}",
        ]
        # per-category opex
        for k in opex_keys:
            row.append(f"{model['opex_lines'][k][ym].quantize(CENT)}")
        row.extend([
            f"{model['opex_total'][ym].quantize(CENT)}",
            f"{model['depreciation'][ym].quantize(CENT)}",
            f"{model['interest'][ym].quantize(CENT)}",
            f"{(model['revenue'][ym]-model['cogs'][ym]-model['opex_total'][ym]-model['depreciation'][ym]-model['interest'][ym]).quantize(CENT)}",
        ])
        exp_rows.append(row)
    write_csv(out_dir / '30_exploitatie.csv', exp_header, exp_rows)

    # 40_qredits_maandlasten.md + amortisatie.csv
    write_text(out_dir / '40_qredits_maandlasten.md', qredits_md(model))
    amort = model['amort_rows']
    write_csv(out_dir / '40_amortisatie.csv', ['maand','verstrekker','rente_pm','aflossing_pm','restschuld'], [
        [r['maand'], r['verstrekker'], f"{Decimal(str(r['rente_pm'])).quantize(CENT)}", f"{Decimal(str(r['aflossing_pm'])).quantize(CENT)}", f"{Decimal(str(r['restschuld'])).quantize(CENT)}"] for r in amort
    ])

    # 50_belastingen.md + tax.csv (indicatief)
    write_text(out_dir / '50_belastingen.md', tax_md(model))
    bel = model['config'].get('belastingen', {})
    tax_rows = [[model['config'].get('belastingen', {}).get('regime','IB'), bel.get('btw_pct',21), bel.get('btw_model','omzet_enkel'), bel.get('kor', False), bel.get('btw_vrij', False)]]
    write_csv(out_dir / '50_tax.csv', ['regime','btw_pct','btw_model','kor','btw_vrij'], tax_rows)

    # zz_schema.md
    write_text(out_dir / 'zz_schema.md', schema_md())


# ----------------------------
# CLI
# ----------------------------

def cmd_scan(args: argparse.Namespace) -> None:
    roots = [Path(p).resolve() for p in args.roots]
    out_dir = Path(args.out).resolve()
    ensure_dir(out_dir / 'meta')
    scan_roots(roots, out_dir / 'meta')
    print(f"Context index written to {out_dir / 'meta' / 'context_index.json'}")


def cmd_run(args: argparse.Namespace) -> None:
    in_path = Path(args.input).resolve()
    out_dir = Path(args.out).resolve()
    ensure_dir(out_dir)

    cfg = load_input(in_path)
    months = int(args.months)
    if months <= 0:
        raise SystemExit('--months moet > 0 zijn')
    scenario = args.scenario
    if scenario not in ('base','best','worst'):
        raise SystemExit('--scenario moet base|best|worst zijn')
    vat_period = args.vat_period
    if vat_period not in ('monthly','quarterly'):
        raise SystemExit('--vat-period moet monthly|quarterly zijn')

    model = compute_model(cfg, months, scenario, vat_period)
    write_reports(out_dir, model)

    # one-screen summary
    print("=== Samenvatting ===")
    print(f"Laagste kasstand: {money(model['lowest_cash'])} (maand {model['lowest_cash_month']})")
    print(f"Gem. EBITDA: {money(model['avg_ebitda'])}")
    print(f"Gem. schuldendienst: {money(model['avg_debt_service'])}")
    cov = model['coverage']
    cov_str = str((cov.quantize(D('0.01')) if isinstance(cov, Decimal) else D(str(cov)).quantize(D('0.01')))) + 'x'
    print(f"Maandlast-dekking: {cov_str}")
    print(f"Scenario: {scenario}, BTW-periode: {vat_period}")


def build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(description='Financieel Plan Generator (NL)')
    sub = p.add_subparsers(dest='cmd', required=True)

    p_scan = sub.add_parser('scan', help='Scan repository text roots for context index')
    p_scan.add_argument('--roots', nargs='+', required=True, help='One or more roots to scan')
    p_scan.add_argument('--out', required=True, help='Output directory (e.g., ./out)')
    p_scan.set_defaults(func=cmd_scan)

    p_run = sub.add_parser('run', help='Run financial model and emit reports')
    p_run.add_argument('input', help='Input file .yml|.yaml|.json')
    p_run.add_argument('--out', required=True, help='Output directory')
    p_run.add_argument('--months', type=int, default=12, help='Number of months')
    p_run.add_argument('--scenario', choices=['base','best','worst'], default='base')
    p_run.add_argument('--vat-period', choices=['monthly','quarterly'], default='monthly')
    p_run.set_defaults(func=cmd_run)

    return p


def main(argv: Optional[List[str]] = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)
    try:
        args.func(args)
    except Exception as e:
        print(f"Fout: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
