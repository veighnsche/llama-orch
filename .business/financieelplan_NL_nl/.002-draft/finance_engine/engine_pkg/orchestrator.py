from __future__ import annotations

from typing import Any, Dict, Tuple, Optional
import pandas as pd

from ..config import OUTPUTS
from ..io.writer import write_text
from .ports import RenderPort, ValidatePort

# Step modules (keep runner thin and modular)
from .steps.load_validate import (
    load_inputs as _load_inputs,
    write_run_summary as _write_run_summary,
    validate_and_write_report as _validate_and_write_report,
)
from .steps.compute import compute_all as _compute_all
from .steps.artifacts import write_artifacts as _write_artifacts
from .steps.charts import generate_charts as _generate_charts
from .steps.context import build_context as _build_context
from .steps.render import render_plan as _render_plan


def load_inputs() -> Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any], pd.DataFrame, pd.DataFrame]:
    return _load_inputs()


def write_run_summary() -> Dict[str, Any]:
    return _write_run_summary()


def validate_and_write_report(
    config: Dict[str, Any],
    costs: Dict[str, Any],
    lending: Dict[str, Any],
    price_sheet: pd.DataFrame,
    *,
    validate_port: Optional[ValidatePort] = None,
) -> bool:
    return _validate_and_write_report(config, costs, lending, price_sheet, validate_port=validate_port)


# Pipeline steps to be filled in small patches

def compute_all(config: Dict[str, Any], extra: Dict[str, Any], lending: Dict[str, Any], price_sheet: pd.DataFrame, gpu_df: pd.DataFrame) -> Dict[str, Any]:
    return _compute_all(
        config=config,
        extra=extra,
        lending=lending,
        price_sheet=price_sheet,
        gpu_df=gpu_df,
    )


def write_artifacts(config: Dict[str, Any], agg: Dict[str, Any]) -> None:
    _write_artifacts(config=config, agg=agg)


def generate_charts(agg: Dict[str, Any]) -> Dict[str, str]:
    return _generate_charts(agg=agg)


def build_context(agg: Dict[str, Any], charts: Dict[str, str], config: Dict[str, Any], extra: Dict[str, Any], lending: Dict[str, Any]) -> Dict[str, Any]:
    return _build_context(agg=agg, charts=charts, config=config, extra=extra, lending=lending)


def render_plan(context: Dict[str, Any], *, render_port: Optional[RenderPort] = None) -> None:
    _render_plan(context=context, render_port=render_port)


def run_pipeline(*, render_port: Optional[RenderPort] = None, validate_port: Optional[ValidatePort] = None) -> int:
    config, costs, lending, extra, price_sheet, gpu_df = load_inputs()
    write_run_summary()
    has_errors = validate_and_write_report(config, costs, lending, price_sheet, validate_port=validate_port)
    if has_errors:
        return 1
    agg = compute_all(config, extra, lending, price_sheet, gpu_df)
    write_artifacts(config, agg)
    charts = generate_charts(agg)
    ctx = build_context(agg, charts, config, extra, lending)
    render_plan(context=ctx, render_port=render_port)
    # Legacy shim for older tests
    write_text(OUTPUTS / "template_filled.md", "Generated by engine v1\n")
    return 0
