diff --git a/bin/00_rbee_keeper/src/job_client.rs b/bin/00_rbee_keeper/src/job_client.rs
index d5b770bc..de669309 100644
--- a/bin/00_rbee_keeper/src/job_client.rs
+++ b/bin/00_rbee_keeper/src/job_client.rs
@@ -38,6 +38,9 @@ pub async fn submit_and_stream_job(
 ) -> Result<()> {
     // TEAM-186: Serialize operation here (DRY - single place!)
     let job_payload = serde_json::to_value(&operation).expect("Failed to serialize operation");
+    
+    // Note: correlation_id is generated by queen if not provided
+    // Clients CAN optionally provide one, but it's not required
 
     // Ensure queen is running
     let queen_handle = ensure_queen_running(queen_url).await?;
diff --git a/bin/99_shared_crates/narration-core/src/builder.rs b/bin/99_shared_crates/narration-core/src/builder.rs
index dd89d97f..252484ff 100644
--- a/bin/99_shared_crates/narration-core/src/builder.rs
+++ b/bin/99_shared_crates/narration-core/src/builder.rs
@@ -41,6 +41,7 @@ use serde_json::Value;
 ///     .human("âœ… Queen started on {0}, port {1}")  // {0} or {} = first context, {1} = second
 ///     .emit();
 /// ```
+#[derive(Clone)]
 pub struct Narration {
     fields: NarrationFields,
     /// TEAM-191: Store context values for format string interpolation
@@ -77,6 +78,34 @@ impl Narration {
         }
     }
 
+    /// Set the action for this narration.
+    ///
+    /// Useful when building narrations from a job-scoped factory.
+    ///
+    /// # Example
+    /// ```rust,ignore
+    /// let JOB = NARRATE.with_job_id("job-123");
+    /// JOB.action("hive_start").human("Starting hive").emit();
+    /// ```
+    pub fn action(mut self, action: &'static str) -> Self {
+        // Runtime check for action length (same as NarrationFactory)
+        const MAX_ACTION_LENGTH: usize = 15;
+        let char_count = action.chars().count();
+        assert!(
+            char_count <= MAX_ACTION_LENGTH,
+            "Action string is too long! Maximum 15 characters allowed. Got '{}' ({} chars)",
+            action,
+            char_count
+        );
+        
+        self.fields.action = action;
+        // If target is empty, use action as target (backwards compat)
+        if self.fields.target.is_empty() {
+            self.fields.target = action.to_string();
+        }
+        self
+    }
+
     /// Add context value for format string interpolation.
     ///
     /// Context values can be referenced in `.human()`, `.cute()`, and `.story()`
@@ -341,15 +370,6 @@ impl Narration {
         self
     }
 
-    /// Emit the narration at INFO level with auto-injection.
-    ///
-    /// Automatically injects service identity and timestamp.
-    ///
-    /// Note: Use the `narrate!` macro instead to capture caller's crate name.
-    pub fn emit(self) {
-        crate::narrate(self.fields)
-    }
-
     /// Emit with explicit provenance (internal use by macro)
     #[doc(hidden)]
     pub fn emit_with_provenance(mut self, crate_name: &str, crate_version: &str) {
@@ -365,6 +385,26 @@ impl Narration {
         crate::narrate(self.fields)
     }
 
+    /// Emit the narration event to all configured outputs.
+    ///
+    /// Automatically injects service identity and timestamp.
+    /// Also automatically includes task-local context (job_id, correlation_id) if set.
+    ///
+    /// Note: Use the `narrate!` macro instead to capture caller's crate name.
+    pub fn emit(mut self) {
+        // Automatically include task-local context if available
+        if let Some(ctx) = crate::context::get_context() {
+            if self.fields.job_id.is_none() {
+                self.fields.job_id = ctx.job_id;
+            }
+            if self.fields.correlation_id.is_none() {
+                self.fields.correlation_id = ctx.correlation_id;
+            }
+        }
+        
+        crate::narrate(self.fields)
+    }
+
     /// Emit the narration at WARN level with auto-injection.
     pub fn emit_warn(self) {
         crate::narrate_warn(self.fields)
@@ -690,6 +730,54 @@ impl NarrationFactory {
     pub const fn actor(&self) -> &'static str {
         self.actor
     }
+
+    /// Create a job-scoped narration builder with job_id baked in.
+    ///
+    /// Returns a `Narration` that automatically includes the job_id,
+    /// so you don't have to call `.job_id()` on every narration.
+    ///
+    /// # Example
+    /// ```rust
+    /// use observability_narration_core::NarrationFactory;
+    ///
+    /// const NARRATE: NarrationFactory = NarrationFactory::new("qn-router");
+    /// 
+    /// // Create job-scoped factory
+    /// let JOB = NARRATE.with_job_id("job-abc123");
+    /// 
+    /// // No need to call .job_id() anymore!
+    /// JOB.action("hive_start").human("Starting hive").emit();
+    /// JOB.action("hive_check").human("Checking status").emit();
+    /// ```
+    pub fn with_job_id(&self, job_id: impl Into<String>) -> Narration {
+        let mut fields = NarrationFields::default();
+        fields.actor = self.actor;
+        fields.job_id = Some(job_id.into());
+        
+        Narration {
+            fields,
+            context_values: Vec::new(),
+        }
+    }
+}
+
+/// Format a job ID to show only last 6 characters with "..." prefix.
+///
+/// Makes logs more readable by truncating long UUIDs.
+///
+/// # Example
+/// ```
+/// use observability_narration_core::short_job_id;
+///
+/// assert_eq!(short_job_id("job-abc123def456"), "...def456");
+/// assert_eq!(short_job_id("short"), "short");
+/// ```
+pub fn short_job_id(job_id: &str) -> String {
+    if job_id.len() > 6 {
+        format!("...{}", &job_id[job_id.len() - 6..])
+    } else {
+        job_id.to_string()
+    }
 }
 
 #[cfg(test)]
diff --git a/bin/99_shared_crates/narration-core/src/lib.rs b/bin/99_shared_crates/narration-core/src/lib.rs
index 899ffea1..f3968172 100644
--- a/bin/99_shared_crates/narration-core/src/lib.rs
+++ b/bin/99_shared_crates/narration-core/src/lib.rs
@@ -65,11 +65,13 @@
 
 mod builder;
 mod capture;
+pub mod context;
 pub mod correlation;
 pub mod sse_sink;
 pub mod unicode;
 
-pub use builder::{Narration, NarrationFactory};
+pub use builder::{short_job_id, Narration, NarrationFactory};
+pub use context::{with_narration_context, NarrationContext};
 pub use capture::{CaptureAdapter, CapturedNarration};
 
 /// Macro to emit narration with automatic caller crate provenance.
