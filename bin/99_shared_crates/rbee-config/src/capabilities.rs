//! Capabilities cache (capabilities.yaml)
//!
//! Created by: TEAM-193
//!
//! Auto-generated cache of device capabilities for each hive.
//! This file is managed by queen-rbee and should not be edited manually.

use crate::error::{ConfigError, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// Capabilities cache for all hives
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CapabilitiesCache {
    #[serde(skip)]
    path: PathBuf,

    /// Last time this cache was updated
    pub last_updated: String,

    /// Capabilities per hive
    pub hives: HashMap<String, HiveCapabilities>,
}

/// Capabilities for a single hive
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct HiveCapabilities {
    /// Hive alias
    pub alias: String,

    /// Detected devices
    pub devices: Vec<DeviceInfo>,

    /// Last update timestamp (milliseconds since epoch)
    pub last_updated_ms: i64,

    /// Hive endpoint (e.g., "http://localhost:8081")
    /// TEAM-196: Added for capabilities refresh
    pub endpoint: String,
}

/// Device information
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct DeviceInfo {
    /// Device ID (e.g., "GPU-0", "CPU-0")
    pub id: String,

    /// Device name (e.g., "NVIDIA RTX 4090")
    pub name: String,

    /// VRAM in GB (for GPUs)
    pub vram_gb: u32,

    /// Compute capability (for CUDA GPUs)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compute_capability: Option<String>,

    /// Device type
    /// TEAM-196: Added for device classification
    pub device_type: DeviceType,
}

/// Device type classification
/// TEAM-196: Added for Phase 4 capabilities
/// TEAM-209: Added missing documentation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DeviceType {
    /// GPU device (NVIDIA, AMD, Apple Metal)
    Gpu,
    /// CPU device (fallback compute device)
    Cpu,
}

impl CapabilitiesCache {
    /// Create new empty cache
    pub fn new(path: PathBuf) -> Self {
        Self { path, last_updated: Utc::now().to_rfc3339(), hives: HashMap::new() }
    }

    /// Create from hashmap (for testing)
    #[cfg(test)]
    pub(crate) fn from_map(
        path: PathBuf,
        last_updated: String,
        hives: HashMap<String, HiveCapabilities>,
    ) -> Self {
        Self { path, last_updated, hives }
    }

    /// Load from capabilities.yaml file
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be read or parsed
    pub fn load(path: &Path) -> Result<Self> {
        if !path.exists() {
            // Return empty cache if file doesn't exist
            return Ok(Self::new(path.to_path_buf()));
        }

        let content = std::fs::read_to_string(path)
            .map_err(|e| ConfigError::ReadError { path: path.to_path_buf(), source: e })?;

        let mut cache: Self = serde_yaml::from_str(&content)
            .map_err(|e| ConfigError::YamlParseError { path: path.to_path_buf(), source: e })?;

        cache.path = path.to_path_buf();
        Ok(cache)
    }

    /// Save to disk
    ///
    /// # Errors
    ///
    /// Returns an error if the file cannot be written or serialization fails
    pub fn save(&self) -> Result<()> {
        // Add header comment
        let mut content = String::from(
            "# Auto-generated by queen-rbee\n\
             # DO NOT EDIT MANUALLY\n\n",
        );

        let yaml = serde_yaml::to_string(&self)?;
        content.push_str(&yaml);

        std::fs::write(&self.path, content)
            .map_err(|e| ConfigError::WriteError { path: self.path.clone(), source: e })
    }

    /// Update capabilities for a hive
    pub fn update_hive(&mut self, alias: &str, caps: HiveCapabilities) {
        self.hives.insert(alias.to_string(), caps);
        self.last_updated = Utc::now().to_rfc3339();
    }

    /// Get capabilities for a hive
    pub fn get(&self, alias: &str) -> Option<&HiveCapabilities> {
        self.hives.get(alias)
    }

    /// Remove capabilities for a hive
    pub fn remove(&mut self, alias: &str) -> Option<HiveCapabilities> {
        let result = self.hives.remove(alias);
        if result.is_some() {
            self.last_updated = Utc::now().to_rfc3339();
        }
        result
    }

    /// Check if hive has capabilities cached
    pub fn contains(&self, alias: &str) -> bool {
        self.hives.contains_key(alias)
    }

    /// Get all hive aliases with cached capabilities
    pub fn aliases(&self) -> Vec<String> {
        self.hives.keys().cloned().collect()
    }

    /// Number of hives with cached capabilities
    pub fn len(&self) -> usize {
        self.hives.len()
    }

    /// Check if cache is empty
    pub fn is_empty(&self) -> bool {
        self.hives.is_empty()
    }
}

impl HiveCapabilities {
    /// Create new capabilities for a hive
    /// TEAM-196: Updated to include endpoint parameter
    pub fn new(alias: String, devices: Vec<DeviceInfo>, endpoint: String) -> Self {
        Self { alias, devices, last_updated_ms: Utc::now().timestamp_millis(), endpoint }
    }

    /// Check if hive has any GPUs
    pub fn has_gpu(&self) -> bool {
        self.devices.iter().any(|d| matches!(d.device_type, DeviceType::Gpu))
    }

    /// Get GPU count
    pub fn gpu_count(&self) -> usize {
        self.devices.iter().filter(|d| matches!(d.device_type, DeviceType::Gpu)).count()
    }

    /// Get total VRAM across all GPUs
    pub fn total_vram_gb(&self) -> u32 {
        self.devices.iter().map(|d| d.vram_gb).sum()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;

    #[test]
    fn test_new_cache() {
        let path = PathBuf::from("/tmp/test.yaml");
        let cache = CapabilitiesCache::new(path.clone());
        assert_eq!(cache.path, path);
        assert!(cache.is_empty());
    }

    #[test]
    fn test_load_nonexistent_file() {
        let path = Path::new("/nonexistent/capabilities.yaml");
        let cache = CapabilitiesCache::load(path).unwrap();
        assert!(cache.is_empty());
    }

    #[test]
    fn test_update_and_get() {
        let path = PathBuf::from("/tmp/test.yaml");
        let mut cache = CapabilitiesCache::new(path);

        let caps = HiveCapabilities::new(
            "test-hive".to_string(),
            vec![DeviceInfo {
                id: "GPU-0".to_string(),
                name: "RTX 4090".to_string(),
                vram_gb: 24,
                compute_capability: Some("8.9".to_string()),
                device_type: DeviceType::Gpu,
            }],
            "http://localhost:8081".to_string(),
        );

        cache.update_hive("test-hive", caps.clone());
        assert_eq!(cache.len(), 1);
        assert!(cache.contains("test-hive"));

        let retrieved = cache.get("test-hive").unwrap();
        assert_eq!(retrieved.alias, "test-hive");
        assert_eq!(retrieved.devices.len(), 1);
    }

    #[test]
    fn test_remove() {
        let path = PathBuf::from("/tmp/test.yaml");
        let mut cache = CapabilitiesCache::new(path);

        let caps = HiveCapabilities::new(
            "test-hive".to_string(),
            vec![],
            "http://localhost:8081".to_string(),
        );
        cache.update_hive("test-hive", caps);

        assert_eq!(cache.len(), 1);
        let removed = cache.remove("test-hive");
        assert!(removed.is_some());
        assert_eq!(cache.len(), 0);
    }

    #[test]
    fn test_save_and_load() {
        let file = NamedTempFile::new().unwrap();
        let mut cache = CapabilitiesCache::new(file.path().to_path_buf());

        let caps = HiveCapabilities::new(
            "localhost".to_string(),
            vec![
                DeviceInfo {
                    id: "GPU-0".to_string(),
                    name: "RTX 4090".to_string(),
                    vram_gb: 24,
                    compute_capability: Some("8.9".to_string()),
                    device_type: DeviceType::Gpu,
                },
                DeviceInfo {
                    id: "GPU-1".to_string(),
                    name: "RTX 3060".to_string(),
                    vram_gb: 12,
                    compute_capability: Some("8.6".to_string()),
                    device_type: DeviceType::Gpu,
                },
            ],
            "http://localhost:8081".to_string(),
        );

        cache.update_hive("localhost", caps);
        cache.save().unwrap();

        let loaded = CapabilitiesCache::load(file.path()).unwrap();
        assert_eq!(loaded.len(), 1);

        let localhost = loaded.get("localhost").unwrap();
        assert_eq!(localhost.alias, "localhost");
        assert_eq!(localhost.devices.len(), 2);
        assert_eq!(localhost.devices[0].name, "RTX 4090");
    }

    #[test]
    fn test_hive_capabilities_helpers() {
        let caps = HiveCapabilities::new(
            "test".to_string(),
            vec![
                DeviceInfo {
                    id: "GPU-0".to_string(),
                    name: "RTX 4090".to_string(),
                    vram_gb: 24,
                    compute_capability: Some("8.9".to_string()),
                    device_type: DeviceType::Gpu,
                },
                DeviceInfo {
                    id: "GPU-1".to_string(),
                    name: "RTX 3060".to_string(),
                    vram_gb: 12,
                    compute_capability: None,
                    device_type: DeviceType::Gpu,
                },
            ],
            "http://localhost:8081".to_string(),
        );

        assert!(caps.has_gpu());
        assert_eq!(caps.gpu_count(), 2);
        assert_eq!(caps.total_vram_gb(), 36);
    }

    #[test]
    fn test_yaml_format() {
        let file = NamedTempFile::new().unwrap();
        let mut cache = CapabilitiesCache::new(file.path().to_path_buf());

        let caps = HiveCapabilities::new(
            "localhost".to_string(),
            vec![DeviceInfo {
                id: "GPU-0".to_string(),
                name: "RTX 4090".to_string(),
                vram_gb: 24,
                compute_capability: Some("8.9".to_string()),
                device_type: DeviceType::Gpu,
            }],
            "http://localhost:8081".to_string(),
        );

        cache.update_hive("localhost", caps);
        cache.save().unwrap();

        let content = std::fs::read_to_string(file.path()).unwrap();
        assert!(content.contains("# Auto-generated by queen-rbee"));
        assert!(content.contains("# DO NOT EDIT MANUALLY"));
        assert!(content.contains("localhost:"));
        assert!(content.contains("RTX 4090"));
    }
}
