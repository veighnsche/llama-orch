# TEAM-328: `#[with_job_id]` Attribute Macro

**Status:** ✅ COMPLETE  
**Date:** Oct 27, 2025

## Problem

Repetitive boilerplate in every async function that needs job_id context for SSE routing:

```rust
pub async fn some_function(config: SomeConfig) -> Result<()> {
    // BOILERPLATE (7-17 lines repeated in every function)
    let ctx = config
        .job_id
        .as_ref()
        .map(|jid| NarrationContext::new().with_job_id(jid));

    let impl_fn = async {
        // Actual implementation here
        n!("action", "Doing thing");
        Ok(())
    };

    // Execute with context if job_id provided
    if let Some(ctx) = ctx {
        with_narration_context(ctx, impl_fn).await
    } else {
        impl_fn.await
    }
}
```

**Impact:** 
- ~15 lines of boilerplate per function
- Found in 5+ files across daemon-lifecycle
- Easy to forget or implement incorrectly
- Clutters the actual business logic

## Solution

Created `#[with_job_id]` attribute macro that automatically injects the boilerplate:

```rust
#[with_job_id]  // Auto-detects "config" parameter
pub async fn some_function(config: SomeConfig) -> Result<()> {
    // Just write your implementation
    n!("action", "Doing thing");
    Ok(())
}
```

## Usage

### Auto-detection (recommended)

Macro automatically finds the first parameter with "config" in its name:

```rust
use observability_narration_macros::with_job_id;
use observability_narration_core::n;

#[with_job_id]  // Auto-detects "rebuild_config"
pub async fn build_daemon_local(config: RebuildConfig) -> Result<String> {
    n!("build_start", "⏳ Running cargo build...");
    // ... implementation
    Ok(binary_path)
}
```

### Explicit parameter name

For functions with multiple config parameters:

```rust
#[with_job_id(config_param = "rebuild_config")]
pub async fn rebuild_with_hot_reload(
    rebuild_config: RebuildConfig,
    daemon_config: HttpDaemonConfig,
) -> Result<bool> {
    n!("start", "Starting rebuild...");
    // ... implementation
    Ok(true)
}
```

## Requirements

1. **Function must be `async`**
2. **Config parameter must have `job_id: Option<String>` field**
3. **Must import:**
   ```rust
   use observability_narration_core::n;
   use observability_narration_macros::with_job_id;
   ```

## How It Works

The macro transforms your function by:

1. Extracting `job_id` from the config parameter
2. Creating `NarrationContext` if job_id exists
3. Wrapping your function body with `with_narration_context` if needed
4. Otherwise executing directly

**Generated code:**
```rust
pub async fn your_function(config: YourConfig) -> Result<()> {
    // Auto-generated by #[with_job_id]
    let __ctx = config
        .job_id
        .as_ref()
        .map(|jid| ::observability_narration_core::NarrationContext::new().with_job_id(jid));

    let __impl = async move {
        // Your original function body here
    };

    if let Some(__ctx) = __ctx {
        ::observability_narration_core::with_narration_context(__ctx, __impl).await
    } else {
        __impl.await
    }
}
```

## Code Reduction

### Before (rebuild.rs example)

**Function 1: `build_daemon_local`** - 56 lines total
- Boilerplate: 15 lines (27%)
- Implementation: 41 lines (73%)

**Function 2: `rebuild_with_hot_reload`** - 70 lines total
- Boilerplate: 17 lines (24%)
- Implementation: 53 lines (76%)

**Total:** 126 lines (32 lines boilerplate)

### After

**Function 1: `build_daemon_local`** - 42 lines total
- Macro: 1 line
- Implementation: 41 lines (98%)

**Function 2: `rebuild_with_hot_reload`** - 54 lines total
- Macro: 1 line
- Implementation: 53 lines (98%)

**Total:** 96 lines (2 lines macro)

**Savings:** 30 lines removed (24% reduction)

## Files Modified

### New Files
- `bin/99_shared_crates/narration-macros/src/with_job_id.rs` (117 LOC)

### Modified Files
- `bin/99_shared_crates/narration-macros/src/lib.rs` (+43 lines)
- `bin/99_shared_crates/daemon-lifecycle/Cargo.toml` (+1 dependency)
- `bin/99_shared_crates/daemon-lifecycle/src/rebuild.rs` (-30 lines)

## Potential Impact

**Files with the pattern (daemon-lifecycle):**
- `src/rebuild.rs` - 2 functions ✅ MIGRATED
- `src/shutdown.rs` - 2 functions
- `src/health.rs` - 1 function
- `src/list.rs` - 1 function
- `src/uninstall.rs` - 1 function

**Estimated total savings:** ~100-150 lines across daemon-lifecycle alone

**Other crates with similar patterns:**
- `queen-rbee-hive-lifecycle` - 9 operations
- `auto-update` - 3+ functions
- Any future lifecycle crates

**Total potential savings:** 300-500 lines across the monorepo

## Benefits

1. **Less boilerplate** - 15 lines → 1 line per function
2. **Harder to get wrong** - Macro handles it correctly every time
3. **Clearer intent** - Business logic not buried in boilerplate
4. **Easier to maintain** - Change once in macro, applies everywhere
5. **Type-safe** - Compiler verifies everything

## Testing

```bash
# Verify compilation
cargo check -p daemon-lifecycle

# Verify macro works
cargo test -p daemon-lifecycle
```

## Migration Guide

For each function with the pattern:

1. **Add import:**
   ```rust
   use observability_narration_macros::with_job_id;
   ```

2. **Add attribute:**
   ```rust
   #[with_job_id]  // or #[with_job_id(config_param = "your_config")]
   pub async fn your_function(config: YourConfig) -> Result<()> {
   ```

3. **Remove boilerplate:**
   - Delete `let ctx = config.job_id...` block
   - Delete `let impl_fn = async { ... };` wrapper
   - Delete `if let Some(ctx) = ctx { ... }` block
   - Keep only the actual implementation

4. **Remove unused imports:**
   ```rust
   // Remove these if no longer used:
   use observability_narration_core::{with_narration_context, NarrationContext};
   ```

5. **Verify:**
   ```bash
   cargo check -p your-crate
   ```

## Example: Full Migration

**Before:**
```rust
use observability_narration_core::{n, with_narration_context, NarrationContext};

pub async fn install_daemon(config: InstallConfig) -> Result<()> {
    let ctx = config
        .job_id
        .as_ref()
        .map(|jid| NarrationContext::new().with_job_id(jid));

    let impl_fn = async {
        n!("install_start", "Installing {}...", config.daemon_name);
        // ... actual implementation
        n!("install_complete", "✅ Installation complete");
        Ok(())
    };

    if let Some(ctx) = ctx {
        with_narration_context(ctx, impl_fn).await
    } else {
        impl_fn.await
    }
}
```

**After:**
```rust
use observability_narration_core::n;
use observability_narration_macros::with_job_id;

#[with_job_id]
pub async fn install_daemon(config: InstallConfig) -> Result<()> {
    n!("install_start", "Installing {}...", config.daemon_name);
    // ... actual implementation
    n!("install_complete", "✅ Installation complete");
    Ok(())
}
```

**Result:** 20 lines → 8 lines (60% reduction)

## Future Work

Potential candidates for similar macros:

1. **`#[with_timeout]`** - Auto-wrap with TimeoutEnforcer
2. **`#[with_retry]`** - Auto-retry on failure
3. **`#[with_metrics]`** - Auto-emit duration metrics

## Notes

- Macro uses `__ctx` and `__impl` as internal variable names (unlikely to conflict)
- Works with any return type (Result, Option, custom types)
- Compatible with other attribute macros (can stack with `#[narrate_fn]`)
- Zero runtime overhead (pure compile-time transformation)

---

**TEAM-328 Signature:** All code in this feature tagged with TEAM-328 comments
