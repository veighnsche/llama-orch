# rbee-config

**Created by:** TEAM-193  
**Purpose:** File-based configuration for rbee following Unix best practices

## Overview

This crate provides file-based configuration management for rbee, replacing the SQLite-based `hive-catalog` with human-editable config files.

## Configuration Files

All config files are stored in `~/.config/rbee/`:

### 1. `config.toml` - Queen-level settings

```toml
[queen]
port = 8080
log_level = "info"

[runtime]
max_concurrent_operations = 10
```

### 2. `hives.conf` - SSH/hive definitions (SSH config style)

```ssh-config
# Localhost hive
Host localhost
    HostName 127.0.0.1
    Port 22
    User vince
    HivePort 8081
    BinaryPath /usr/local/bin/rbee-hive

# Remote workstation
Host workstation
    HostName 192.168.1.100
    Port 22
    User admin
    HivePort 8081
```

**Supported fields:**
- `Host` - Hive alias (required)
- `HostName` - IP address or hostname (required)
- `Port` - SSH port (default: 22)
- `User` - SSH username (required)
- `HivePort` - Hive HTTP API port (required)
- `BinaryPath` - Path to rbee-hive binary (optional)

### 3. `capabilities.yaml` - Auto-generated device capabilities

```yaml
# Auto-generated by queen-rbee
# DO NOT EDIT MANUALLY
last_updated: 2025-10-21T20:40:00Z

hives:
  localhost:
    alias: localhost
    devices:
      - id: "GPU-0"
        name: "NVIDIA RTX 4090"
        vram_gb: 24
        compute_capability: "8.9"
    last_updated_ms: 1729540800000
```

## API

### Load Configuration

```rust
use rbee_config::RbeeConfig;

// Load all config files from ~/.config/rbee/
let config = RbeeConfig::load()?;

// Access queen settings
println!("Queen port: {}", config.queen.queen.port);

// Access hive by alias
if let Some(hive) = config.hives.get("localhost") {
    println!("Hive: {}@{}:{}", hive.ssh_user, hive.hostname, hive.hive_port);
}

// Check capabilities
if let Some(caps) = config.capabilities.get("localhost") {
    println!("GPUs: {}", caps.gpu_count());
    println!("Total VRAM: {} GB", caps.total_vram_gb());
}
```

### Validation

```rust
// Validate configuration
let result = config.validate()?;

if !result.is_valid() {
    for error in &result.errors {
        eprintln!("ERROR: {}", error);
    }
}

if result.has_warnings() {
    for warning in &result.warnings {
        eprintln!("WARNING: {}", warning);
    }
}
```

### Update Capabilities

```rust
use rbee_config::{HiveCapabilities, DeviceInfo};

// Create capabilities
let caps = HiveCapabilities::new(
    "localhost".to_string(),
    vec![DeviceInfo {
        id: "GPU-0".to_string(),
        name: "RTX 4090".to_string(),
        vram_gb: 24,
        compute_capability: Some("8.9".to_string()),
    }],
);

// Update cache
config.capabilities.update_hive("localhost", caps);
config.save_capabilities()?;
```

## Module Structure

- `lib.rs` - Main API and RbeeConfig struct
- `queen_config.rs` - TOML parser for config.toml
- `hives_config.rs` - SSH config parser for hives.conf
- `capabilities.rs` - YAML reader/writer for capabilities.yaml
- `validation.rs` - Configuration validation
- `error.rs` - Error types

## Design Principles

1. **Human-editable** - Users manually edit `hives.conf` using standard SSH config syntax
2. **Unix conventions** - Config files in `~/.config/rbee/`
3. **Auto-generated cache** - Capabilities are detected and cached automatically
4. **Validation** - Preflight checks on startup
5. **No database** - Simple file-based storage

## Migration from hive-catalog

The old SQLite-based `hive-catalog` stored:
- Hive ID, host, port, SSH credentials
- Device capabilities
- Runtime status (moved to `hive-registry`)

The new file-based system:
- ✅ Hive config → `hives.conf` (user-editable)
- ✅ Device capabilities → `capabilities.yaml` (auto-generated)
- ✅ Runtime status → `hive-registry` (in-memory)

## Testing

```bash
# Run all tests
cargo test -p rbee-config

# Run with output
cargo test -p rbee-config -- --nocapture

# Run specific test
cargo test -p rbee-config test_load_from_dir
```

## Examples

See `tests/` directory for comprehensive examples of:
- Parsing valid and invalid configs
- Handling missing files
- Validation scenarios
- Capabilities management
