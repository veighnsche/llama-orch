# Phase 4: Capabilities Auto-Generation

**Team:** TEAM-191  
**Duration:** 4-5 hours  
**Dependencies:** Phase 3 (TEAM-190) complete  
**Deliverables:** Auto-generated `capabilities.yaml` with device discovery

---

## Mission

Implement automatic capabilities discovery and caching. When a hive starts, queen-rbee should fetch device information and store it in `capabilities.yaml` for fast lookups.

---

## Tasks

### 4.1 Capabilities Data Model

**In `bin/15_queen_rbee_crates/rbee-config/src/capabilities.rs`:**

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CapabilitiesCache {
    /// Last time the cache was updated
    pub last_updated: String, // ISO 8601 timestamp
    
    /// Capabilities per hive (keyed by alias)
    pub hives: HashMap<String, HiveCapabilities>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HiveCapabilities {
    /// Hive alias (matches hives.conf)
    pub alias: String,
    
    /// Discovered devices
    pub devices: Vec<DeviceInfo>,
    
    /// Last update timestamp (milliseconds since epoch)
    pub last_updated_ms: i64,
    
    /// Hive endpoint
    pub endpoint: String, // e.g., "http://localhost:8081"
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceInfo {
    /// Device ID (e.g., "GPU-0", "CPU-0")
    pub id: String,
    
    /// Device name (e.g., "NVIDIA RTX 4090")
    pub name: String,
    
    /// VRAM in GB (for GPUs)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vram_gb: Option<u32>,
    
    /// Compute capability (for CUDA GPUs)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub compute_capability: Option<String>,
    
    /// Device type
    pub device_type: DeviceType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DeviceType {
    Gpu,
    Cpu,
}

impl CapabilitiesCache {
    /// Load from ~/.config/rbee/capabilities.yaml
    pub fn load() -> Result<Self, ConfigError> {
        let path = Self::path();
        
        if !path.exists() {
            // Return empty cache if file doesn't exist
            return Ok(Self::empty());
        }
        
        let content = std::fs::read_to_string(&path)?;
        let cache: CapabilitiesCache = serde_yaml::from_str(&content)?;
        
        Ok(cache)
    }
    
    /// Save to disk
    pub fn save(&self) -> Result<(), ConfigError> {
        let path = Self::path();
        
        // Ensure parent directory exists
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }
        
        // Serialize with header comment
        let yaml = serde_yaml::to_string(&self)?;
        let content = format!(
            "# Auto-generated by queen-rbee\n\
             # DO NOT EDIT MANUALLY\n\
             # Last updated: {}\n\
             \n\
             {}",
            chrono::Utc::now().to_rfc3339(),
            yaml
        );
        
        std::fs::write(&path, content)?;
        
        Ok(())
    }
    
    /// Get capabilities for a hive
    pub fn get(&self, alias: &str) -> Option<&HiveCapabilities> {
        self.hives.get(alias)
    }
    
    /// Update capabilities for a hive
    pub fn update_hive(&mut self, alias: String, caps: HiveCapabilities) {
        self.hives.insert(alias, caps);
        self.last_updated = chrono::Utc::now().to_rfc3339();
    }
    
    /// Remove capabilities for a hive
    pub fn remove_hive(&mut self, alias: &str) {
        self.hives.remove(alias);
        self.last_updated = chrono::Utc::now().to_rfc3339();
    }
    
    /// List all hives with capabilities
    pub fn all(&self) -> Vec<&HiveCapabilities> {
        self.hives.values().collect()
    }
    
    /// Create empty cache
    fn empty() -> Self {
        Self {
            last_updated: chrono::Utc::now().to_rfc3339(),
            hives: HashMap::new(),
        }
    }
    
    /// Get path to capabilities.yaml
    fn path() -> PathBuf {
        crate::RbeeConfig::config_dir().join("capabilities.yaml")
    }
}
```

### 4.2 Hive Capabilities API Client

**In `bin/10_queen_rbee/src/hive_client.rs` (new file):**

```rust
use anyhow::{Context, Result};
use rbee_config::{DeviceInfo, DeviceType};
use serde::{Deserialize, Serialize};

/// Response from hive's /capabilities endpoint
#[derive(Debug, Deserialize)]
pub struct HiveCapabilitiesResponse {
    pub devices: Vec<HiveDevice>,
}

#[derive(Debug, Deserialize)]
pub struct HiveDevice {
    pub id: String,
    pub name: String,
    pub device_type: String, // "gpu" or "cpu"
    pub vram_gb: Option<u32>,
    pub compute_capability: Option<String>,
}

/// Fetch capabilities from a running hive
pub async fn fetch_hive_capabilities(endpoint: &str) -> Result<Vec<DeviceInfo>> {
    let url = format!("{}/capabilities", endpoint);
    
    let response = reqwest::get(&url)
        .await
        .context("Failed to connect to hive")?;
    
    if !response.status().is_success() {
        anyhow::bail!(
            "Hive returned error: {} {}",
            response.status(),
            response.text().await.unwrap_or_default()
        );
    }
    
    let caps: HiveCapabilitiesResponse = response
        .json()
        .await
        .context("Failed to parse capabilities response")?;
    
    // Convert to our format
    let devices = caps.devices
        .into_iter()
        .map(|d| DeviceInfo {
            id: d.id,
            name: d.name,
            vram_gb: d.vram_gb,
            compute_capability: d.compute_capability,
            device_type: match d.device_type.as_str() {
                "gpu" => DeviceType::Gpu,
                "cpu" => DeviceType::Cpu,
                _ => DeviceType::Cpu, // Default to CPU
            },
        })
        .collect();
    
    Ok(devices)
}

/// Health check for hive
pub async fn check_hive_health(endpoint: &str) -> Result<bool> {
    let url = format!("{}/health", endpoint);
    
    let response = reqwest::get(&url)
        .await
        .context("Failed to connect to hive")?;
    
    Ok(response.status().is_success())
}
```

### 4.3 Update HiveInstall to Fetch Capabilities

**In `bin/10_queen_rbee/src/job_router.rs`:**

```rust
Operation::HiveInstall { alias } => {
    // ... existing preflight checks ...
    
    // After starting the hive process:
    
    // STEP 4: Wait for hive to be ready
    let endpoint = format!("http://{}:{}", hive.hostname, hive.hive_port);
    
    NARRATE_ROUTER
        .action("hive_install_health_check")
        .human("‚è≥ Waiting for hive to be ready...")
        .emit();
    
    // Poll health endpoint
    let mut attempts = 0;
    let max_attempts = 30; // 30 seconds
    let mut healthy = false;
    
    while attempts < max_attempts {
        if let Ok(true) = check_hive_health(&endpoint).await {
            healthy = true;
            break;
        }
        
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        attempts += 1;
    }
    
    if !healthy {
        return Err(anyhow::anyhow!(
            "Hive failed to start within {} seconds",
            max_attempts
        ));
    }
    
    NARRATE_ROUTER
        .action("hive_install_health_check")
        .human("‚úÖ Hive is healthy")
        .emit();
    
    // STEP 5: Fetch capabilities
    NARRATE_ROUTER
        .action("hive_install_capabilities")
        .human("üìä Fetching device capabilities...")
        .emit();
    
    let devices = fetch_hive_capabilities(&endpoint)
        .await
        .context("Failed to fetch capabilities")?;
    
    NARRATE_ROUTER
        .action("hive_install_capabilities")
        .human(format!("‚úÖ Discovered {} device(s)", devices.len()))
        .emit();
    
    // Log discovered devices
    for device in &devices {
        let device_info = match device.device_type {
            DeviceType::Gpu => {
                format!(
                    "  üéÆ {} - {} (VRAM: {} GB, Compute: {})",
                    device.id,
                    device.name,
                    device.vram_gb.unwrap_or(0),
                    device.compute_capability.as_deref().unwrap_or("unknown")
                )
            }
            DeviceType::Cpu => {
                format!("  üñ•Ô∏è  {} - {}", device.id, device.name)
            }
        };
        
        NARRATE_ROUTER
            .action("hive_install_device_discovered")
            .human(device_info)
            .emit();
    }
    
    // STEP 6: Update capabilities cache
    NARRATE_ROUTER
        .action("hive_install_cache_update")
        .human("üíæ Updating capabilities cache...")
        .emit();
    
    let caps = HiveCapabilities {
        alias: alias.clone(),
        devices,
        last_updated_ms: chrono::Utc::now().timestamp_millis(),
        endpoint: endpoint.clone(),
    };
    
    // Update and save
    let mut config = state.config.as_ref().clone();
    config.capabilities.update_hive(alias.clone(), caps);
    config.capabilities.save()?;
    
    // Update state
    *state.config = Arc::new(config);
    
    NARRATE_ROUTER
        .action("hive_install_cache_update")
        .human("‚úÖ Capabilities cached")
        .emit();
    
    Narration::new(ACTOR_QUEEN_ROUTER, "hive_install_complete", &alias)
        .human(format!(
            "‚úÖ Hive '{}' installed successfully!\n\
             \n\
             Endpoint: {}\n\
             Devices: {}",
            alias,
            endpoint,
            config.capabilities.get(&alias)
                .map(|c| c.devices.len().to_string())
                .unwrap_or_else(|| "0".to_string())
        ))
        .emit();
}
```

### 4.4 Update HiveUninstall to Remove Capabilities

```rust
Operation::HiveUninstall { alias } => {
    // ... existing uninstall logic ...
    
    // Remove from capabilities cache
    if state.config.capabilities.get(&alias).is_some() {
        NARRATE_ROUTER
            .action("hive_uninstall_cache_cleanup")
            .human("üóëÔ∏è  Removing from capabilities cache...")
            .emit();
        
        let mut config = state.config.as_ref().clone();
        config.capabilities.remove_hive(&alias);
        config.capabilities.save()?;
        
        *state.config = Arc::new(config);
    }
    
    // ... rest of uninstall
}
```

### 4.5 Add Capabilities Refresh Command

**New operation:**

```rust
Operation::HiveRefreshCapabilities { alias } => {
    Narration::new(ACTOR_QUEEN_ROUTER, "hive_refresh_capabilities", &alias)
        .human(format!("üîÑ Refreshing capabilities for '{}'", alias))
        .emit();
    
    // Get hive config
    let hive = validate_hive_exists(&state.config, &alias)?;
    
    // Check if hive is running
    let caps = state.config.capabilities.get(&alias)
        .ok_or_else(|| anyhow::anyhow!(
            "Hive '{}' is not running. Start it first with:\n\
             \n\
               ./rbee hive start -h {}",
            alias, alias
        ))?;
    
    // Fetch fresh capabilities
    NARRATE_ROUTER
        .action("hive_refresh_capabilities_fetching")
        .human("üìä Fetching device capabilities...")
        .emit();
    
    let devices = fetch_hive_capabilities(&caps.endpoint)
        .await
        .context("Failed to fetch capabilities")?;
    
    NARRATE_ROUTER
        .action("hive_refresh_capabilities_fetched")
        .human(format!("‚úÖ Discovered {} device(s)", devices.len()))
        .emit();
    
    // Update cache
    let updated_caps = HiveCapabilities {
        alias: alias.clone(),
        devices,
        last_updated_ms: chrono::Utc::now().timestamp_millis(),
        endpoint: caps.endpoint.clone(),
    };
    
    let mut config = state.config.as_ref().clone();
    config.capabilities.update_hive(alias.clone(), updated_caps);
    config.capabilities.save()?;
    
    *state.config = Arc::new(config);
    
    Narration::new(ACTOR_QUEEN_ROUTER, "hive_refresh_capabilities_complete", &alias)
        .human("‚úÖ Capabilities refreshed")
        .emit();
}
```

### 4.6 Add CLI Command

**In `bin/00_rbee_keeper/src/config.rs`:**

```rust
#[derive(Parser)]
enum HiveCommand {
    // ... existing commands ...
    
    /// Refresh device capabilities for a hive
    RefreshCapabilities {
        #[arg(short = 'h', long = "host")]
        alias: String,
    },
}
```

### 4.7 Write Integration Tests

**In `bin/15_queen_rbee_crates/rbee-config/tests/capabilities_tests.rs`:**

```rust
use rbee_config::{CapabilitiesCache, HiveCapabilities, DeviceInfo, DeviceType};

#[test]
fn test_capabilities_save_and_load() {
    let mut cache = CapabilitiesCache::empty();
    
    let caps = HiveCapabilities {
        alias: "test-hive".to_string(),
        devices: vec![
            DeviceInfo {
                id: "GPU-0".to_string(),
                name: "NVIDIA RTX 4090".to_string(),
                vram_gb: Some(24),
                compute_capability: Some("8.9".to_string()),
                device_type: DeviceType::Gpu,
            },
        ],
        last_updated_ms: 1729540800000,
        endpoint: "http://localhost:8081".to_string(),
    };
    
    cache.update_hive("test-hive".to_string(), caps);
    
    // Save
    cache.save().unwrap();
    
    // Load
    let loaded = CapabilitiesCache::load().unwrap();
    
    assert_eq!(loaded.hives.len(), 1);
    assert!(loaded.get("test-hive").is_some());
}

#[test]
fn test_capabilities_remove_hive() {
    let mut cache = CapabilitiesCache::empty();
    
    // Add hive
    cache.update_hive("test-hive".to_string(), /* ... */);
    assert!(cache.get("test-hive").is_some());
    
    // Remove hive
    cache.remove_hive("test-hive");
    assert!(cache.get("test-hive").is_none());
}
```

---

## Acceptance Criteria

- [ ] Capabilities are fetched after hive installation
- [ ] `capabilities.yaml` is auto-generated with header comment
- [ ] Capabilities cache is updated when hives start
- [ ] Capabilities are removed when hives are uninstalled
- [ ] Refresh command updates capabilities for running hives
- [ ] All tests pass
- [ ] YAML format is human-readable

---

## Verification Commands

```bash
# Install a hive and check capabilities
./rbee hive install -h localhost
cat ~/.config/rbee/capabilities.yaml

# Refresh capabilities
./rbee hive refresh-capabilities -h localhost

# Test capabilities module
cargo test -p rbee-config capabilities
```

---

## Handoff to TEAM-192

**What's ready:**
- ‚úÖ Auto-generated capabilities cache
- ‚úÖ Device discovery on hive installation
- ‚úÖ Capabilities refresh command
- ‚úÖ Cache cleanup on uninstall

**Next steps:**
- Code peer review (Phase 5)
- Verify all edge cases handled
- Check error messages are clear

---

**Created by:** TEAM-187  
**For:** TEAM-191  
**Status:** üìã Ready to implement
