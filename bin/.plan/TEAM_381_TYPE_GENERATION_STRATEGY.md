# TEAM-381: Type Generation Strategy - Rust ‚Üí TypeScript

**Date:** 2025-11-01  
**Status:** üìã PROPOSED

## Problem

Currently, types are manually duplicated:
- ‚ùå Rust defines `ModelInfo` in `operations-contract`
- ‚ùå TypeScript manually defines `Model` in SDK
- ‚ùå No automatic synchronization
- ‚ùå Risk of drift between Rust and TypeScript

## Solution: Use `tsify` for Automatic Type Generation

### What is `tsify`?

`tsify` is a crate that automatically generates TypeScript types from Rust structs using `serde` and `wasm-bindgen`.

**Benefits:**
- ‚úÖ Define types once in Rust
- ‚úÖ TypeScript types generated automatically
- ‚úÖ No manual synchronization needed
- ‚úÖ Type safety guaranteed

### Current State

**Rust (operations-contract):**
```rust
// bin/97_contracts/operations-contract/src/responses.rs
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ModelInfo {
    pub id: String,
    pub name: String,
    pub size_bytes: u64,
    pub status: String,
    pub loaded: Option<bool>,
    pub vram_mb: Option<u64>,
}
```

**TypeScript (manually duplicated):**
```typescript
// bin/20_rbee_hive/ui/packages/rbee-hive-sdk/src/index.ts
export interface Model {
  id: string
  name: string
  size: number
  status: string
  loaded?: boolean
  vram_mb?: number
}
```

### Proposed Solution

**Step 1: Add `tsify` to operations-contract**

```toml
# bin/97_contracts/operations-contract/Cargo.toml
[dependencies]
tsify = { version = "0.4", optional = true }
wasm-bindgen = { version = "0.2", optional = true }

[features]
wasm = ["tsify", "wasm-bindgen"]
```

**Step 2: Annotate Rust structs**

```rust
// bin/97_contracts/operations-contract/src/responses.rs
use serde::{Deserialize, Serialize};
#[cfg(feature = "wasm")]
use tsify::Tsify;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[cfg_attr(feature = "wasm", derive(Tsify))]
#[cfg_attr(feature = "wasm", tsify(into_wasm_abi, from_wasm_abi))]
pub struct ModelInfo {
    pub id: String,
    pub name: String,
    pub size_bytes: u64,
    pub status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub loaded: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vram_mb: Option<u64>,
}
```

**Step 3: Enable feature in SDK**

```toml
# bin/20_rbee_hive/ui/packages/rbee-hive-sdk/Cargo.toml
[dependencies]
operations-contract = { path = "../../../../97_contracts/operations-contract", features = ["wasm"] }
tsify = "0.4"
```

**Step 4: Re-export generated types**

```rust
// bin/20_rbee_hive/ui/packages/rbee-hive-sdk/src/lib.rs
pub use operations_contract::{ModelInfo, ModelListResponse, HFModel};
```

**Step 5: TypeScript imports generated types**

```typescript
// bin/20_rbee_hive/ui/packages/rbee-hive-sdk/src/index.ts
// Types are automatically generated by tsify!
export type { ModelInfo, ModelListResponse } from './pkg/bundler/rbee_hive_sdk'
```

## Implementation Plan

### Phase 1: Add tsify to operations-contract
- [ ] Add `tsify` and `wasm-bindgen` as optional dependencies
- [ ] Add `wasm` feature flag
- [ ] Annotate response types with `#[cfg_attr(feature = "wasm", derive(Tsify))]`
- [ ] Test that types compile with and without `wasm` feature

### Phase 2: Enable in SDK
- [ ] Enable `wasm` feature in operations-contract dependency
- [ ] Re-export types from operations-contract
- [ ] Remove manual TypeScript type definitions
- [ ] Rebuild SDK and verify generated types

### Phase 3: Update React layer
- [ ] Import types from SDK (generated)
- [ ] Remove manual type definitions
- [ ] Test that hooks work with generated types

### Phase 4: Update UI layer
- [ ] Import types from React layer
- [ ] Remove manual type definitions
- [ ] Test that components work with generated types

## Types to Generate

### From operations-contract/responses.rs
- `ModelInfo` ‚Üí TypeScript `ModelInfo`
- `ModelListResponse` ‚Üí TypeScript `ModelListResponse`
- `ModelDownloadResponse` ‚Üí TypeScript `ModelDownloadResponse`
- `ModelGetResponse` ‚Üí TypeScript `ModelGetResponse`
- `ModelDeleteResponse` ‚Üí TypeScript `ModelDeleteResponse`
- `WorkerInfo` ‚Üí TypeScript `WorkerInfo`
- `WorkerListResponse` ‚Üí TypeScript `WorkerListResponse`

### From operations-contract/requests.rs
- `ModelListRequest` ‚Üí TypeScript `ModelListRequest`
- `ModelDownloadRequest` ‚Üí TypeScript `ModelDownloadRequest`
- `ModelDeleteRequest` ‚Üí TypeScript `ModelDeleteRequest`
- `WorkerSpawnRequest` ‚Üí TypeScript `WorkerSpawnRequest`

### HuggingFace Types (UI-only)
These stay in TypeScript (not from backend):
- `HFModel` - HuggingFace API response
- `FilterState` - UI filter state
- `ViewMode` - UI view mode

## Example: Generated TypeScript

**Input (Rust):**
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
#[tsify(into_wasm_abi, from_wasm_abi)]
pub struct ModelInfo {
    pub id: String,
    pub name: String,
    pub size_bytes: u64,
    pub status: String,
    pub loaded: Option<bool>,
    pub vram_mb: Option<u64>,
}
```

**Output (TypeScript - auto-generated):**
```typescript
export interface ModelInfo {
  id: string;
  name: string;
  size_bytes: number; // u64 ‚Üí number
  status: string;
  loaded?: boolean;   // Option<bool> ‚Üí boolean | undefined
  vram_mb?: number;   // Option<u64> ‚Üí number | undefined
}
```

## Benefits

### ‚úÖ Single Source of Truth
- Types defined once in Rust
- TypeScript types generated automatically
- No manual synchronization

### ‚úÖ Type Safety
- Rust compiler enforces correctness
- TypeScript gets exact same types
- No drift between backend and frontend

### ‚úÖ Maintainability
- Update types in one place (Rust)
- TypeScript updates automatically
- No manual type definitions

### ‚úÖ Developer Experience
- Autocomplete in TypeScript
- Type errors at compile time
- Clear ownership (Rust owns types)

## Comparison

### Before (Manual)
```
Rust: ModelInfo { id, name, size_bytes, ... }
  ‚Üì (manual copy-paste)
TypeScript: Model { id, name, size, ... }
  ‚Üì (risk of drift)
‚ùå size_bytes vs size mismatch!
```

### After (Generated)
```
Rust: ModelInfo { id, name, size_bytes, ... }
  ‚Üì (tsify generates)
TypeScript: ModelInfo { id, name, size_bytes, ... }
  ‚Üì (exact match)
‚úÖ Perfect synchronization!
```

## Migration Steps

1. **Add tsify to operations-contract**
2. **Annotate Rust structs with `#[derive(Tsify)]`**
3. **Enable wasm feature in SDK**
4. **Remove manual TypeScript types**
5. **Import generated types**
6. **Test and verify**

## Alternative: `wasm-bindgen` alone

If `tsify` is too heavy, we can use `wasm-bindgen` directly:

```rust
#[wasm_bindgen]
pub struct ModelInfo {
    pub id: String,
    pub name: String,
    // ...
}
```

But `tsify` is better because:
- ‚úÖ Works with `serde` (already used)
- ‚úÖ Generates proper TypeScript interfaces
- ‚úÖ Handles Option<T>, Vec<T>, etc. correctly
- ‚úÖ No need to rewrite structs

## Summary

**Current:** Types manually duplicated in Rust and TypeScript  
**Proposed:** Types defined once in Rust, generated for TypeScript  
**Tool:** `tsify` crate for automatic generation  
**Benefit:** Single source of truth, no drift, type safety  

**This is the correct architectural approach!** üéØ
