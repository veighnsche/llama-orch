//! Queen-rbee command handlers
//!
//! TEAM-276: Extracted from main.rs
//! TEAM-276: Refactored to use queen-lifecycle crate

use anyhow::Result;
use queen_lifecycle::{
    check_queen_status, get_queen_info, install_queen, rebuild_queen, start_queen, stop_queen,
    uninstall_queen,
};

use crate::cli::QueenAction;

pub async fn handle_queen(action: QueenAction, queen_url: &str) -> Result<()> {
    match action {
        QueenAction::Start => start_queen(queen_url).await,
        QueenAction::Stop => stop_queen(queen_url).await,
        QueenAction::Status => check_queen_status(queen_url).await,
        QueenAction::Rebuild { with_local_hive } => rebuild_queen(with_local_hive).await,
        QueenAction::Info => get_queen_info(queen_url).await,
        QueenAction::Install { binary } => install_queen(binary).await,
        QueenAction::Uninstall => uninstall_queen(queen_url).await,
    }
}

async fn handle_start(queen_url: &str) -> Result<()> {
    let queen_handle = ensure_queen_running(queen_url).await?;
    NARRATE
        .action("queen_start")
        .context(queen_handle.base_url())
        .human("‚úÖ Queen started on {}")
        .emit();
    std::mem::forget(queen_handle);
    Ok(())
}

async fn handle_stop(queen_url: &str) -> Result<()> {
    let client = reqwest::Client::new();

    // First check if queen is running
    let health_check = client.get(format!("{}/health", queen_url)).send().await;

    let is_running = matches!(health_check, Ok(response) if response.status().is_success());

    if !is_running {
        NARRATE.action("queen_stop").human("‚ö†Ô∏è  Queen not running").emit();
        return Ok(());
    }

    // Queen is running, send shutdown request
    let shutdown_client = reqwest::Client::builder()
        .timeout(tokio::time::Duration::from_secs(30))
        .build()?;

    match shutdown_client.post(format!("{}/v1/shutdown", queen_url)).send().await {
        Ok(_) => {
            NARRATE.action("queen_stop").human("‚úÖ Queen stopped").emit();
            Ok(())
        }
        Err(e) => {
            // Connection closed/reset is expected - queen shuts down before responding
            if e.is_connect() || e.to_string().contains("connection closed") {
                NARRATE.action("queen_stop").human("‚úÖ Queen stopped").emit();
                Ok(())
            } else {
                // Unexpected error
                NARRATE
                    .action("queen_stop")
                    .context(e.to_string())
                    .human("‚ö†Ô∏è  Failed to stop queen: {}")
                    .error_kind("shutdown_failed")
                    .emit();
                Err(e.into())
            }
        }
    }
}

async fn handle_status(queen_url: &str) -> Result<()> {
    // TEAM-186: Check queen-rbee health endpoint
    let client = reqwest::Client::builder()
        .timeout(tokio::time::Duration::from_secs(5))
        .build()?;

    match client.get(format!("{}/health", queen_url)).send().await {
        Ok(response) if response.status().is_success() => {
            NARRATE
                .action("queen_status")
                .context(queen_url)
                .human("‚úÖ Queen is running on {}")
                .emit();

            // Try to get more details from the response
            if let Ok(body) = response.text().await {
                println!("Status: {}", body);
            }
            Ok(())
        }
        Ok(response) => {
            NARRATE
                .action("queen_status")
                .context(response.status().to_string())
                .human("‚ö†Ô∏è  Queen responded with status: {}")
                .emit();
            Ok(())
        }
        Err(_) => {
            NARRATE
                .action("queen_status")
                .context(queen_url)
                .human("‚ùå Queen is not running on {}")
                .emit();
            Ok(())
        }
    }
}

async fn handle_rebuild(with_local_hive: bool) -> Result<()> {
    // TEAM-262: Added queen rebuild command for local-hive optimization
    // TEAM-263: Implemented actual build logic
    NARRATE.action("queen_rebuild").human("üî® Rebuilding queen-rbee...").emit();

    // Determine build command
    let mut cmd = std::process::Command::new("cargo");
    cmd.arg("build").arg("--release").arg("--bin").arg("queen-rbee");

    if with_local_hive {
        NARRATE
            .action("queen_rebuild")
            .human("‚ú® Building with integrated local hive (50-100x faster localhost)...")
            .emit();
        cmd.arg("--features").arg("local-hive");
    } else {
        NARRATE
            .action("queen_rebuild")
            .human("üì° Building distributed queen (remote hives only)...")
            .emit();
    }

    // Execute build
    NARRATE
        .action("queen_rebuild")
        .human("‚è≥ Running cargo build (this may take a few minutes)...")
        .emit();

    let output = cmd.output()?;

    if output.status.success() {
        NARRATE.action("queen_rebuild").human("‚úÖ Build successful!").emit();

        // Show binary location
        let binary_path = "target/release/queen-rbee";
        NARRATE
            .action("queen_rebuild")
            .context(binary_path)
            .human("üì¶ Binary available at: {}")
            .emit();

        if with_local_hive {
            NARRATE
                .action("queen_rebuild")
                .human("üí° Restart queen to use the new binary with local-hive feature")
                .emit();
        }
        Ok(())
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr);
        NARRATE
            .action("queen_rebuild")
            .context(stderr.to_string())
            .human("‚ùå Build failed: {}")
            .error_kind("build_failed")
            .emit();
        anyhow::bail!("Build failed");
    }
}

async fn handle_info(queen_url: &str) -> Result<()> {
    // TEAM-262: Query queen's /v1/build-info endpoint
    let client = reqwest::Client::builder()
        .timeout(tokio::time::Duration::from_secs(5))
        .build()?;

    match client.get(format!("{}/v1/build-info", queen_url)).send().await {
        Ok(response) if response.status().is_success() => {
            NARRATE.action("queen_info").human("üìã Queen build information:").emit();
            if let Ok(body) = response.text().await {
                println!("{}", body);
            }
            Ok(())
        }
        Err(_) => {
            NARRATE
                .action("queen_info")
                .human("‚ùå Queen is not running or /v1/build-info not available")
                .emit();
            Ok(())
        }
        _ => {
            NARRATE.action("queen_info").human("‚ö†Ô∏è  Failed to get build info").emit();
            Ok(())
        }
    }
}

async fn handle_install(binary: Option<String>) -> Result<()> {
    // TEAM-262: Install queen binary
    // TEAM-263: Implemented install logic
    // TEAM-276: Refactored to use daemon-lifecycle crate
    NARRATE.action("queen_install").human("üì¶ Installing queen-rbee...").emit();

    // Use daemon-lifecycle to find/validate binary
    let config = InstallConfig {
        binary_name: "queen-rbee".to_string(),
        binary_path: binary,
        target_path: None,
        job_id: None,
    };

    let install_result = install_daemon(config).await?;
    let source_path = std::path::PathBuf::from(&install_result.binary_path);

    // Determine install location (~/.local/bin/queen-rbee)
    let home = std::env::var("HOME")?;
    let install_dir = std::path::PathBuf::from(format!("{}/.local/bin", home));
    let install_path = install_dir.join("queen-rbee");

    // Create install directory if needed
    std::fs::create_dir_all(&install_dir)?;

    // Copy binary
    NARRATE
        .action("queen_install")
        .context(install_path.display().to_string())
        .human("üìã Installing to: {}")
        .emit();

    std::fs::copy(&source_path, &install_path)?;

    // Make executable (Unix only)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = std::fs::metadata(&install_path)?.permissions();
        perms.set_mode(0o755);
        std::fs::set_permissions(&install_path, perms)?;
    }

    NARRATE.action("queen_install").human("‚úÖ Queen installed successfully!").emit();
    NARRATE
        .action("queen_install")
        .context(install_path.display().to_string())
        .human("üìç Binary location: {}")
        .emit();
    NARRATE
        .action("queen_install")
        .human("üí° Make sure ~/.local/bin is in your PATH")
        .emit();

    Ok(())
}

async fn handle_uninstall(queen_url: &str) -> Result<()> {
    // TEAM-262: Uninstall queen binary
    // TEAM-263: Implemented uninstall logic
    // TEAM-276: Refactored to use daemon-lifecycle crate

    // Determine install location
    let home = std::env::var("HOME")?;
    let install_path = std::path::PathBuf::from(format!("{}/.local/bin/queen-rbee", home));

    // Use daemon-lifecycle to handle uninstallation
    let config = UninstallConfig {
        daemon_name: "queen-rbee".to_string(),
        install_path,
        health_url: Some(queen_url.to_string()),
        health_timeout_secs: Some(2),
        job_id: None,
    };

    uninstall_daemon(config).await
}
