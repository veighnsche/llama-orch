//! Job submission client for queen-rbee
//!
//! This is the ONLY way rbee-keeper talks to queen-rbee:
//! 1. Ensure queen is running
//! 2. POST /v1/jobs with operation payload
//! 3. GET /jobs/{job_id}/stream and stream narration to stdout
//! 4. Cleanup queen handle
//!
//! TEAM-185: Updated narration to use operation field instead of embedding in human message
//! TEAM-185: Added hive_id to narration context
//! TEAM-185: Replaced hardcoded action strings with constants from operations module
//! TEAM-186: Accept Operation directly, serialize internally (DRY)
//! TEAM-216: Investigated - Complete behavior inventory created
//! TEAM-259: Refactored to use job-client shared crate

use anyhow::Result;
use job_client::JobClient;
use observability_narration_core::NarrationFactory;
use queen_lifecycle::ensure_queen_running;
use rbee_operations::Operation;
use std::time::Duration;
use timeout_enforcer::TimeoutEnforcer;

// TEAM-192: Local narration factory for job_client.rs
const NARRATE: NarrationFactory = NarrationFactory::new("keeper");

/// Submit a job to queen-rbee and stream its narration output.
///
/// TEAM-186: Now accepts Operation directly instead of pre-serialized JSON
/// TEAM-259: Refactored to use job-client shared crate
///
/// This handles the complete lifecycle:
/// - Ensures queen is running
/// - Submits the job with 10-second timeout
/// - Streams SSE narration events with 30-second timeout
/// - Cleans up queen handle
pub async fn submit_and_stream_job(queen_url: &str, operation: Operation) -> Result<()> {
    // Note: correlation_id is generated by queen if not provided
    // Clients CAN optionally provide one, but it's not required

    // Ensure queen is running
    let queen_handle = ensure_queen_running(queen_url).await?;

    // TEAM-186: Extract metadata before moving operation
    let operation_name = operation.name();
    let hive_id = operation.hive_id().map(|s| s.to_string());

    let mut narration =
        NARRATE.action("job_submit").operation(operation_name).human("üìã Job submitted");

    if let Some(ref hid) = hive_id {
        narration = narration.hive_id(hid);
    }
    narration.emit();

    // TEAM-205: Wrap SSE streaming with 30-second timeout
    // This prevents hanging forever if queen stops responding
    let stream_result = TimeoutEnforcer::new(Duration::from_secs(30))
        .with_label("Streaming job results")
        .silent() // Don't show countdown - narration provides feedback
        .enforce(stream_job_results(queen_url, operation, operation_name, hive_id))
        .await;

    // Cleanup queen handle
    std::mem::forget(queen_handle);

    // Return result (timeout or success)
    stream_result
}

/// Stream job results from queen-rbee
///
/// TEAM-259: Extracted to separate function for clarity
async fn stream_job_results(
    queen_url: &str,
    operation: Operation,
    operation_name: &'static str,
    hive_id: Option<String>,
) -> Result<()> {
    let mut narration =
        NARRATE.action("job_stream").operation(operation_name).human("üì° Streaming results...");

    if let Some(ref hid) = hive_id {
        narration = narration.hive_id(hid);
    }
    narration.emit();

    let mut job_failed = false; // TEAM-189: Track job failures to show proper final status

    // TEAM-259: Use shared JobClient for submission and streaming
    // TEAM-207: JobClient creates its own client with built-in timeout handling
    let job_client = JobClient::new(queen_url);

    job_client
        .submit_and_stream(operation, |line| {
            // Just print the data directly without wrapping in narration
            println!("{}", line);

            // TEAM-189: Track if the job failed
            if line.contains("failed:") || (line.contains("Job") && line.contains("failed")) {
                job_failed = true;
            }

            // Check for [DONE] marker
            if line.contains("[DONE]") {
                // TEAM-189: Show ‚ùå Failed for failures, ‚úÖ Complete for successes
                let mut narration = if job_failed {
                    NARRATE.action("job_complete").operation(operation_name).human("‚ùå Failed")
                } else {
                    NARRATE.action("job_complete").operation(operation_name).human("‚úÖ Complete")
                };

                if let Some(ref hid) = hive_id {
                    narration = narration.hive_id(hid);
                }
                narration.emit();
            }

            Ok(())
        })
        .await?;

    Ok(())
}
