//! llama-orch-utils: M2 applets library for Blueprint pipelines.
//! This crate hosts applets under `src/[namespace]/[applet]/`.

pub mod fs;
pub mod prompt;
pub mod model;
pub mod params;
pub mod llm;
pub mod orch;
pub mod error;

#[cfg(feature = "ts-types")]
pub fn export_ts_types() -> std::io::Result<()> {
    use std::env;
    use std::fs;
    use std::io::Write;
    use std::path::PathBuf;
    use ts_rs::TS;

    // Bring all public I/O types into scope
    use crate::fs::file_reader::{FileBlob, ReadRequest, ReadResponse};
    use crate::fs::file_writer::{WriteIn, WriteOut};
    use crate::prompt::message::{Message, MessageIn, Source};
    use crate::prompt::thread::{ThreadIn, ThreadItem, ThreadOut};
    use crate::model::define::ModelRef;
    use crate::params::define::Params;
    use crate::llm::invoke::{Choice, InvokeIn, InvokeOut, InvokeResult, SdkMsg, Usage};

    let root = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap_or_else(|_| ".".to_string()));
    let out_dir = root.join("npm-build");
    let out_file = out_dir.join("index.d.ts");
    fs::create_dir_all(&out_dir)?;

    let mut buf = String::new();
    buf.push_str("// Auto-generated by export_ts_types (llama-orch-utils). Do not edit.\n\n");

    fn append<T: TS>(buf: &mut String) {
        let mut d = T::decl();
        if d.starts_with("type ") {
            d = d.replacen("type ", "export type ", 1);
        }
        buf.push_str(&d);
        buf.push_str("\n\n");
    }

    // Append declarations for all public applet I/O types
    append::<ReadRequest>(&mut buf);
    append::<FileBlob>(&mut buf);
    append::<ReadResponse>(&mut buf);

    append::<WriteIn>(&mut buf);
    append::<WriteOut>(&mut buf);

    append::<Source>(&mut buf);
    append::<MessageIn>(&mut buf);
    append::<Message>(&mut buf);

    append::<ThreadItem>(&mut buf);
    append::<ThreadIn>(&mut buf);
    append::<ThreadOut>(&mut buf);

    append::<ModelRef>(&mut buf);
    append::<Params>(&mut buf);

    append::<SdkMsg>(&mut buf);
    append::<Choice>(&mut buf);
    append::<Usage>(&mut buf);
    append::<InvokeResult>(&mut buf);
    append::<InvokeIn>(&mut buf);
    append::<InvokeOut>(&mut buf);

    // Append ambient API declarations that reference the Rust-emitted types
    buf.push_str("// Ambient API declarations (M2 DRAFT)\n");
    buf.push_str("export declare const fs: { readFile(input: ReadRequest): ReadResponse; writeFile(input: WriteIn): WriteOut; };\n");
    buf.push_str("export declare const prompt: { message(input: MessageIn): Message; thread(input: ThreadIn): ThreadOut; };\n");
    buf.push_str("export declare const model: { define(model_id: string, engine_id?: string | null, pool_hint?: string | null): ModelRef; };\n");
    buf.push_str("export declare const params: { define(p: Params): Params; };\n");
    buf.push_str("export declare const llm: { invoke(input: InvokeIn): InvokeOut; };\n");
    buf.push_str("export declare const orch: { response_extractor(result: InvokeResult): string; };\n");
    buf.push_str("export declare const _default: { fs: typeof fs; prompt: typeof prompt; model: typeof model; params: typeof params; llm: typeof llm; orch: typeof orch; };\n");
    buf.push_str("export default _default;\n");

    // Write index.d.ts (overwrite)
    let mut f = fs::File::create(&out_file)?;
    f.write_all(buf.as_bytes())?;

    // Also generate package.json (overwrite)
    let pkg_json = r#"{
  \"name\": \"@llama-orch/utils\",
  \"version\": \"0.0.0-draft\",
  \"type\": \"module\",
  \"main\": \"./index.js\",
  \"types\": \"./index.d.ts\",
  \"exports\": { \".\": { \"types\": \"./index.d.ts\", \"default\": \"./index.js\" } },
  \"sideEffects\": false,
  \"license\": \"MIT\"
}
"#;
    fs::write(out_dir.join("package.json"), pkg_json)?;

    // Also generate index.js runtime (overwrite). Only fs.readFile is implemented; others throw.
    let index_js = r#"// Auto-generated by export_ts_types (llama-orch-utils). M2 DRAFT runtime.
const _fs = await (async () => {
  try { return await import('node:fs'); } catch { return await import('fs'); }
})();

function notImpl() { throw new Error('not implemented (M2 DRAFT)'); }

export const fs = {
  readFile(input) {
    if (!input || !Array.isArray(input.paths)) {
      throw new TypeError('readFile: input.paths must be a string[]');
    }
    const asText = !!input.as_text;
    const enc = input.encoding || 'utf-8';
    const files = [];
    for (const p of input.paths) {
      const data = _fs.readFileSync(p);
      if (asText) {
        const content = Buffer.from(data).toString(enc);
        files.push({ path: String(p), content, bytes: null });
      } else {
        const bytes = Array.from(Buffer.from(data).values());
        files.push({ path: String(p), content: null, bytes });
      }
    }
    return { files };
  },
  writeFile: () => notImpl(),
};

export const prompt = {
  message: () => notImpl(),
  thread: () => notImpl(),
};

export const model = { define: () => notImpl() };
export const params = { define: () => notImpl() };
export const llm = { invoke: () => notImpl() };
export const orch = { response_extractor: () => notImpl() };

const _default = { fs, prompt, model, params, llm, orch };
export default _default;
"#;
    fs::write(out_dir.join("index.js"), index_js)?;

    Ok(())
}
