use crate::env::{proof_base_dir, resolve_run_id};
use crate::seeds::SeedsRecorder;
use crate::test_type::TestType;
use crate::util::ensure_ext;
use anyhow::{anyhow, Context, Result};
use serde::Serialize;
use std::fs::{self, File, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};

/// A handle to a proof bundle directory for a specific test type and run.
#[derive(Clone, Debug)]
pub struct ProofBundle {
    pub(crate) root: PathBuf,
}

impl ProofBundle {
    /// Create or open the proof bundle directory for a given test type.
    pub fn for_type(test_type: TestType) -> Result<Self> {
        let base = proof_base_dir()?;
        let run_id = resolve_run_id();
        let root = base.join(test_type.as_dir()).join(run_id);
        fs::create_dir_all(&root).with_context(|| format!("creating proof bundle dir: {}", root.display()))?;
        Ok(Self { root })
    }

    /// Root folder of this bundle.
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// Ensure a subdirectory exists and return its path.
    pub fn ensure_dir<S: AsRef<str>>(&self, sub: S) -> Result<PathBuf> {
        let p = self.root.join(sub.as_ref());
        fs::create_dir_all(&p).with_context(|| format!("creating subdir: {}", p.display()))?;
        Ok(p)
    }

    /// Append a JSON value as a single NDJSON line to `<name>.ndjson`.
    /// If the file is empty or does not exist, write a metadata record first.
    pub fn append_ndjson<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "ndjson");
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?;
        }
        // Ensure metadata record exists first
        let exists_and_nonempty = path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            let mut meta = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&path)
                .with_context(|| format!("open for append: {}", path.display()))?;
            let line = serde_json::to_string(&serde_json::json!({
                "_meta": "proof_bundle",
                "_note": "autogenerated"
            }))?;
            writeln!(meta, "{}", line)?;
        }
        let mut f = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&path)
            .with_context(|| format!("open for append: {}", path.display()))?;
        let line = serde_json::to_string(value)?;
        writeln!(f, "{}", line)?;
        Ok(())
    }

    /// Write a JSON file, overwriting if it exists, and create a sibling `.meta` header file.
    pub fn write_json<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "json");
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?;
        }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        let s = serde_json::to_string_pretty(value)?;
        f.write_all(s.as_bytes())?;
        // Write sibling .meta to signal autogenerated bundle artifact
        let meta = format!("{}{}", path.file_name().unwrap().to_string_lossy(), ".meta");
        self.write_markdown(meta, "# AUTOGENERATED: Proof Bundle\n")?;
        Ok(())
    }

    /// Write a Markdown file, overwriting if it exists. Prepends the required header if missing.
    pub fn write_markdown<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let path = self.root.join(name.as_ref());
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?;
        }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        // Ensure required header is placed first
        if !body.starts_with("# AUTOGENERATED: Proof Bundle\n") {
            f.write_all(b"# AUTOGENERATED: Proof Bundle\n")?;
        }
        f.write_all(body.as_bytes())?;
        Ok(())
    }

    /// Write a Markdown file with the required autogenerated header.
    pub fn write_markdown_with_header<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let mut full = String::from("# AUTOGENERATED: Proof Bundle\n");
        full.push_str(body);
        self.write_markdown(name, &full)
    }

    /// Access a seeds recorder that appends to `seeds.txt`.
    pub fn seeds(&self) -> SeedsRecorder {
        SeedsRecorder {
            path: self.root.join("seeds.txt"),
        }
    }

    /// Ensure the first NDJSON record indicates an autogenerated proof bundle.
    /// If the file already exists and is non-empty, this is a no-op.
    pub fn append_ndjson_autogen_meta<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "ndjson");
        let exists_and_nonempty = path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?;
            }
            let mut f = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&path)
                .with_context(|| format!("open for append: {}", path.display()))?;
            let line = serde_json::to_string(&serde_json::json!({
                "_meta": "proof_bundle",
                "_note": "autogenerated"
            }))?;
            writeln!(f, "{}", line)?;
        }
        Ok(())
    }

    /// Write a sibling `.meta` file next to a JSON/other artifact with the header line.
    pub fn write_meta_sibling<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let meta = format!("{}{}", name.as_ref(), ".meta");
        self.write_markdown(meta, "# AUTOGENERATED: Proof Bundle\n")
    }

    /// Write JSON (pretty) and emit a sibling `.meta` file with the header line.
    pub fn write_json_with_meta<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        self.write_json(&name, value)?;
        // Ensure meta is placed next to the .json filename (e.g., run_config.json.meta)
        let json_name = ensure_ext(PathBuf::from(name.as_ref()), "json");
        let fname = json_name
            .file_name()
            .and_then(|s| Some(s.to_string_lossy().to_string()))
            .ok_or_else(|| anyhow!("invalid file name"))?;
        self.write_meta_sibling(fname)
    }
}
