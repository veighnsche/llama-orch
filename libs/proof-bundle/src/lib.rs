//! proof-bundle â€” Utilities to emit crate-local proof bundles for tests.
//!
//! Standard location: `<crate>/.proof_bundle/<type>/<run_id>/...`
//! - Override base with `LLORCH_PROOF_DIR`
//! - Override run_id with `LLORCH_RUN_ID`
//! - Recommended run_id format: `YYYYMMDD-HHMMSS-<git_sha8>` (fallbacks supported)

use anyhow::{Context, Result};
use serde::Serialize;
use std::env;
use std::fs::{self, File, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::time::{SystemTime, UNIX_EPOCH};

/// Types of proof bundles supported in the monorepo.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
pub enum TestType {
    Unit,
    Integration,
    Contract,
    Bdd,
    Determinism,
    Smoke,
    E2eHaiku,
}

fn ensure_ext(mut p: PathBuf, ext: &str) -> PathBuf {
    if p.extension().and_then(|e| e.to_str()) != Some(ext) {
        p.set_extension(ext);
    }
    p
}

impl TestType {
    pub fn as_dir(self) -> &'static str {
        match self {
            TestType::Unit => "unit",
            TestType::Integration => "integration",
            TestType::Contract => "contract",
            TestType::Bdd => "bdd",
            TestType::Determinism => "determinism",
            TestType::Smoke => "home-profile-smoke",
            TestType::E2eHaiku => "e2e-haiku",
        }
    }
}

/// A handle to a proof bundle directory for a specific test type and run.
#[derive(Clone, Debug)]
pub struct ProofBundle {
    root: PathBuf,
}

impl ProofBundle {
    /// Create or open the proof bundle directory for a given test type.
    pub fn for_type(test_type: TestType) -> Result<Self> {
        let base = proof_base_dir()?;
        let run_id = resolve_run_id();
        let root = base.join(test_type.as_dir()).join(run_id);
        fs::create_dir_all(&root).with_context(|| format!("creating proof bundle dir: {}", root.display()))?;
        Ok(Self { root })
    }

    /// Root folder of this bundle.
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// Ensure a subdirectory exists and return its path.
    pub fn ensure_dir<S: AsRef<str>>(&self, sub: S) -> Result<PathBuf> {
        let p = self.root.join(sub.as_ref());
        fs::create_dir_all(&p).with_context(|| format!("creating subdir: {}", p.display()))?;
        Ok(p)
    }

    /// Append a JSON value as a single NDJSON line to `<name>.ndjson`.
    pub fn append_ndjson<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "ndjson");
        if let Some(parent) = path.parent() { fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?; }
        // Ensure metadata record exists first
        let exists_and_nonempty = path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            let mut meta = OpenOptions::new().create(true).append(true).open(&path)
                .with_context(|| format!("open for append: {}", path.display()))?;
            let line = serde_json::to_string(&serde_json::json!({"_meta":"proof_bundle","_note":"autogenerated"}))?;
            writeln!(meta, "{}", line)?;
        }
        let mut f = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&path)
            .with_context(|| format!("open for append: {}", path.display()))?;
        let line = serde_json::to_string(value)?;
        writeln!(f, "{}", line)?;
        Ok(())
    }

    /// Write a JSON file, overwriting if it exists.
    pub fn write_json<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "json");
        if let Some(parent) = path.parent() { fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?; }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        let s = serde_json::to_string_pretty(value)?;
        f.write_all(s.as_bytes())?;
        // Write sibling .meta to signal autogenerated bundle artifact
        let meta = format!("{}{}", path.file_name().unwrap().to_string_lossy(), ".meta");
        self.write_markdown(meta, "# AUTOGENERATED: Proof Bundle\n")?;
        Ok(())
    }

    /// Write a Markdown file, overwriting if it exists.
    pub fn write_markdown<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let path = self.root.join(name.as_ref());
        if let Some(parent) = path.parent() { fs::create_dir_all(parent).with_context(|| format!("create parent: {}", parent.display()))?; }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        // Ensure required header is placed first
        if !body.starts_with("# AUTOGENERATED: Proof Bundle\n") {
            f.write_all(b"# AUTOGENERATED: Proof Bundle\n")?;
        }
        f.write_all(body.as_bytes())?;
        Ok(())
    }

    /// Write a Markdown file with the required autogenerated header.
    pub fn write_markdown_with_header<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let mut full = String::from("# AUTOGENERATED: Proof Bundle\n");
        full.push_str(body);
        self.write_markdown(name, &full)
    }

    /// Access a seeds recorder that appends to `seeds.txt`.
    pub fn seeds(&self) -> SeedsRecorder {
        SeedsRecorder {
            path: self.root.join("seeds.txt"),
        }
    }

    /// Ensure the first NDJSON record indicates an autogenerated proof bundle.
    /// If the file already exists and is non-empty, this is a no-op.
    pub fn append_ndjson_autogen_meta<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let path = ensure_ext(self.root.join(name.as_ref()), "ndjson");
        let exists_and_nonempty = path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            self.append_ndjson(name, &serde_json::json!({
                "_meta": "proof_bundle",
                "_note": "autogenerated"
            }))?
        }
        Ok(())
    }

    /// Write a sibling `.meta` file next to a JSON/other artifact with the header line.
    pub fn write_meta_sibling<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let meta = format!("{}{}", name.as_ref(), ".meta");
        self.write_markdown(meta, "# AUTOGENERATED: Proof Bundle\n")
    }

    /// Write JSON (pretty) and emit a sibling `.meta` file with the header line.
    pub fn write_json_with_meta<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        self.write_json(&name, value)?;
        // Ensure meta is placed next to the .json filename (e.g., run_config.json.meta)
        let json_name = ensure_ext(PathBuf::from(name.as_ref()), "json");
        let fname = json_name
            .file_name()
            .and_then(|s| Some(s.to_string_lossy().to_string()))
            .ok_or_else(|| anyhow::anyhow!("invalid file name"))?;
        self.write_meta_sibling(fname)
    }
}

/// Append seed entries to `seeds.txt`.
#[derive(Clone, Debug)]
pub struct SeedsRecorder {
    path: PathBuf,
}

impl SeedsRecorder {
    pub fn record<S: std::fmt::Display>(&self, seed: S) -> Result<()> {
        let mut f = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.path)
            .with_context(|| format!("open seeds file: {}", self.path.display()))?;
        writeln!(f, "seed={}", seed)?;
        Ok(())
    }
}

fn proof_base_dir() -> Result<PathBuf> {
    if let Ok(dir) = env::var("LLORCH_PROOF_DIR") {
        return Ok(PathBuf::from(dir));
    }
    // Default: current working directory (Cargo typically runs tests with CWD at the crate root)
    let cwd = std::env::current_dir().context("resolve current_dir")?;
    Ok(cwd.join(".proof_bundle"))
}

fn resolve_run_id() -> String {
    if let Ok(id) = env::var("LLORCH_RUN_ID") {
        return id;
    }
    let ts = epoch_seconds();
    if let Some(sha8) = resolve_sha8() {
        format!("{}-{}", ts, sha8)
    } else {
        ts
    }
}

fn epoch_seconds() -> String {
    let secs = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    format!("{}", secs)
}

fn resolve_sha8() -> Option<String> {
    // Prefer explicit envs often set by CI
    let cand = env::var("GIT_SHA").ok()
        .or_else(|| env::var("CI_COMMIT_SHA").ok())
        .or_else(|| env::var("GITHUB_SHA").ok());
    cand.map(|s| s.chars().take(8).collect())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn creates_bundle_dirs() {
        let pb = ProofBundle::for_type(TestType::Unit).unwrap();
        assert!(pb.root().exists());
        pb.ensure_dir("sub").unwrap();
        assert!(pb.root().join("sub").exists());
    }

    #[test]
    fn writes_files() {
        let pb = ProofBundle::for_type(TestType::Integration).unwrap();
        pb.write_markdown("test_report.md", "# OK\n").unwrap();
        pb.write_json("run_config", &serde_json::json!({"ok": true})).unwrap();
        pb.append_ndjson("streaming_transcript", &serde_json::json!({"event":"started"})).unwrap();
        pb.seeds().record(42).unwrap();
    }
}
