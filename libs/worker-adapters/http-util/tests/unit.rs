use worker_adapters_http_util as http_util;
use http_util::{
    default_config, get_and_clear_retry_timeline, redact_secrets, stream_decode,
    with_bearer, with_retries, RetryError, RetryPolicy, StreamEvent,
};
use proof_bundle::{ProofBundle, TestType};
use serde_json::json;

fn pb() -> ProofBundle { ProofBundle::for_type(TestType::Unit).expect("proof bundle") }

#[test]
fn redaction_masks_bearer_and_x_api_key() {
    let token = "secretTokenXYZ";
    let line = format!("INFO: Authorization: Bearer {} used", token);
    let red = redact_secrets(&line);
    assert!(red.contains("Authorization: Bearer ****"));
    assert!(!red.contains(token));

    let api_key = "api_key_123456789";
    let line2 = format!("WARN: X-API-Key: {}", api_key);
    let red2 = redact_secrets(&line2);
    assert!(red2.to_lowercase().contains("x-api-key: ****"));
    assert!(!red2.contains(&api_key));

    let _ = pb().write_markdown("test_report.md", "# AUTOGENERATED: Proof Bundle\nunit redaction ok\n");
}

#[tokio::test]
async fn retries_seeded_timeline_bounds() {
    let mut policy = RetryPolicy::default();
    policy.seed = Some(7);
    let res: Result<u32, RetryError> = with_retries(
        |attempt| async move {
            if attempt < 3 { Err(RetryError::Retriable(anyhow::anyhow!("503 transient"))) } else { Ok(attempt) }
        },
        policy.clone(),
    ).await;
    assert!(matches!(res, Ok(3)));
    let timeline = get_and_clear_retry_timeline();
    assert_eq!(timeline.len(), 2);
    let bounds = [200u64.min(2000), 400u64.min(2000)];
    for (i, &d) in timeline.iter().enumerate() {
        assert!(d <= bounds[i], "delay {} > bound {}: {:?}", i, bounds[i], timeline);
        let _ = pb().append_ndjson("retry_timeline", &json!({"attempt": i+1, "delay_ms": d, "seed": policy.seed}));
    }
    if let Some(seed) = policy.seed { let _ = pb().seeds().record(seed); }
    let _ = pb().write_json("metadata", &json!({"test": "retries_seeded_timeline_bounds"}));
}

#[test]
fn stream_decode_sequence_and_indices() {
    let body = "event: started\n\
                data: {\"ts\":1}\n\
                \n\
                event: token\n\
                data: {\"i\":0,\"t\":\"Hello\"}\n\
                \n\
                event: token\n\
                data: {\"i\":1,\"t\":\"!\"}\n\
                \n\
                event: end\n\
                data: {}\n";
    let mut events = Vec::new();
    let _ = stream_decode(body, |e| events.push(e));
    // order
    let seq: Vec<&'static str> = events.iter().map(|e| match e { StreamEvent::Started(_) => "started", StreamEvent::Token{..} => "token", StreamEvent::Metrics(_) => "metrics", StreamEvent::End(_) => "end" }).collect();
    let a = seq.iter().position(|s| *s == "started").unwrap();
    let b = seq.iter().position(|s| *s == "token").unwrap();
    let c = seq.iter().position(|s| *s == "end").unwrap();
    assert!(a < b && b < c);
    // indices
    let idx: Vec<usize> = events.into_iter().filter_map(|e| match e { StreamEvent::Token{i, ..} => Some(i), _ => None }).collect();
    for w in idx.windows(2) { assert!(w[0] < w[1]); }
    let _ = pb().append_ndjson("streaming_transcript", &json!({"sequence": seq, "indices": idx}));
}

#[test]
fn defaults_and_bearer_helper() {
    let cfg = default_config();
    let c = format!("{:?}", cfg.connect_timeout);
    let r = format!("{:?}", cfg.request_timeout);
    assert!(c.contains("5s"));
    assert!(r.contains("30s"));

    let client = http_util::client();
    let rb = client.get("http://localhost/");
    let rb = with_bearer(rb, "my-token");
    let req = rb.build().unwrap();
    let got = req.headers().get(http::header::AUTHORIZATION).unwrap().to_str().unwrap();
    assert_eq!(got, "Bearer my-token");
}

#[test]
fn retry_after_and_status_classification() {
    use http_util::{parse_retry_after, is_retriable_status, is_non_retriable_status};
    assert_eq!(parse_retry_after("120"), Some(120_000));
    assert_eq!(parse_retry_after("  5  "), Some(5_000));
    assert_eq!(parse_retry_after("Fri, 31 Dec 1999 23:59:59 GMT"), None);

    assert!(is_retriable_status(500));
    assert!(is_retriable_status(503));
    assert!(is_retriable_status(429));
    assert!(!is_retriable_status(400));
    assert!(is_non_retriable_status(400));
    assert!(is_non_retriable_status(401));
    assert!(is_non_retriable_status(403));
    assert!(is_non_retriable_status(404));
    assert!(is_non_retriable_status(422));
}
