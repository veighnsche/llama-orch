#!/usr/bin/env bash
# BDD Test Runner with Live Output and Selective Capture
# Created by: TEAM-102
# Modified by: TEAM-111 - Enhanced for real-time visibility and robustness
# Usage: ./run-bdd-tests.sh [--tags @auth] [--feature lifecycle] [--quiet]

set -euo pipefail

# TEAM-111: Trap handler for cleanup and error reporting
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]] && [[ $exit_code -ne 1 ]]; then
        echo ""
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
        echo -e "${RED}⚠️  Script terminated unexpectedly with exit code: $exit_code${NC}" >&2
        echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}" >&2
        if [[ -n "${LOG_FILE:-}" ]] && [[ -f "$LOG_FILE" ]]; then
            echo -e "${YELLOW}Check logs at: $LOG_FILE${NC}" >&2
        fi
    fi
}
trap cleanup EXIT

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
LOG_DIR="$SCRIPT_DIR/.test-logs"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
LOG_FILE="$LOG_DIR/bdd-test-$TIMESTAMP.log"
RESULTS_FILE="$LOG_DIR/bdd-results-$TIMESTAMP.txt"

# Default options
TAGS=""
FEATURE=""
QUIET=false  # Default: show all output (user wants to see everything!)

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --tags)
            TAGS="$2"
            shift 2
            ;;
        --feature)
            FEATURE="$2"
            shift 2
            ;;
        --quiet|-q)
            QUIET=true
            shift
            ;;
        --help|-h)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --tags TAG        Run tests with specific tag (e.g., @auth, @p0)"
            echo "  --feature NAME    Run specific feature file (e.g., lifecycle, authentication)"
            echo "  --quiet, -q       Suppress live output (only show summary)"
            echo "  --help, -h        Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0                      # Run all tests with live output"
            echo "  $0 --tags @auth         # Run @auth tests with live output"
            echo "  $0 --feature lifecycle  # Run lifecycle feature with live output"
            echo "  $0 --tags @p0 --quiet   # Run @p0 tests quietly (summary only)"
            echo ""
            echo "Note: By default, ALL stdout/stderr is shown in real-time!"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            exit 1
            ;;
    esac
done

# TEAM-111: Validate we're in the right place
if [[ ! -f "$SCRIPT_DIR/Cargo.toml" ]]; then
    echo -e "${RED}ERROR: Cannot find Cargo.toml in $SCRIPT_DIR${NC}" >&2
    echo -e "${YELLOW}This script must be run from the test-harness/bdd directory${NC}" >&2
    exit 2
fi

if [[ ! -d "$SCRIPT_DIR/tests/features" ]]; then
    echo -e "${YELLOW}WARNING: No tests/features directory found${NC}" >&2
    echo -e "${YELLOW}Expected at: $SCRIPT_DIR/tests/features${NC}" >&2
    echo ""
fi

# Create log directory
mkdir -p "$LOG_DIR"

# Print header
echo -e "${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║           BDD Test Runner - llama-orch Test Harness            ║${NC}"
echo -e "${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}📅 Timestamp:${NC} $TIMESTAMP"
echo -e "${BLUE}📂 Project Root:${NC} $PROJECT_ROOT"
echo -e "${BLUE}📝 Log Directory:${NC} $LOG_DIR"
echo ""

# TEAM-111: Show output mode prominently
if $QUIET; then
    echo -e "${YELLOW}🔇 Output Mode:${NC} QUIET (summary only)"
else
    echo -e "${GREEN}📺 Output Mode:${NC} LIVE (all stdout/stderr shown in real-time)"
fi
echo ""

# Build test command
TEST_CMD="cargo test --test cucumber"

if [[ -n "$TAGS" ]]; then
    TEST_CMD="$TEST_CMD -- --tags $TAGS"
    echo -e "${BLUE}🏷️  Tags:${NC} $TAGS"
fi

if [[ -n "$FEATURE" ]]; then
    TEST_CMD="$TEST_CMD -- $FEATURE"
    echo -e "${BLUE}📋 Feature:${NC} $FEATURE"
fi

echo ""

# Step 1: Check compilation
echo -e "${YELLOW}[1/4]${NC} ${CYAN}Checking compilation...${NC}"
echo ""

# TEAM-111: Avoid pipeline anti-patterns - run to file first, then process
COMPILE_LOG="$LOG_DIR/compile-$TIMESTAMP.log"

if $QUIET; then
    # Quiet mode: capture to file only
    cargo check --lib > "$COMPILE_LOG" 2>&1
    COMPILE_STATUS=$?
else
    # Live mode: show ALL output AND capture to file (using tee properly)
    cargo check --lib 2>&1 | tee "$COMPILE_LOG"
    COMPILE_STATUS=${PIPESTATUS[0]}
fi

# Append to main log file (safe, no pipeline)
cat "$COMPILE_LOG" >> "$LOG_FILE"

if [[ $COMPILE_STATUS -ne 0 ]]; then
    echo ""
    echo -e "${RED}❌ Compilation failed!${NC}"
    echo ""
    if $QUIET; then
        # In quiet mode, show error summary from file
        echo -e "${YELLOW}Compilation errors:${NC}"
        grep "^error" "$COMPILE_LOG" > "$LOG_DIR/errors.tmp" 2>&1 || true
        head -20 "$LOG_DIR/errors.tmp" || echo "  (No error markers found, check log)"
        rm -f "$LOG_DIR/errors.tmp"
        echo ""
    fi
    echo -e "${YELLOW}Full log:${NC} $COMPILE_LOG"
    exit 1
fi

echo ""
echo -e "${GREEN}✅ Compilation successful${NC}"
echo ""

# Step 2: Count test scenarios
echo -e "${YELLOW}[2/4]${NC} ${CYAN}Discovering test scenarios...${NC}"

# TEAM-111: Avoid pipeline anti-patterns - use temp file
SCENARIOS_TMP="$LOG_DIR/scenarios.tmp"
find tests/features -name "*.feature" > "$SCENARIOS_TMP" 2>/dev/null || echo "" > "$SCENARIOS_TMP"

TOTAL_SCENARIOS=0
if [[ -s "$SCENARIOS_TMP" ]]; then
    # Count scenarios from feature files (safe, no pipeline)
    grep -h "^\s*Scenario:" $(cat "$SCENARIOS_TMP") > "$LOG_DIR/scenario-lines.tmp" 2>/dev/null || echo "" > "$LOG_DIR/scenario-lines.tmp"
    TOTAL_SCENARIOS=$(wc -l < "$LOG_DIR/scenario-lines.tmp" 2>/dev/null || echo "0")
    rm -f "$LOG_DIR/scenario-lines.tmp"
fi
rm -f "$SCENARIOS_TMP"

echo -e "${GREEN}📊 Found $TOTAL_SCENARIOS scenarios in feature files${NC}"
echo ""

# Step 3: Run tests
echo -e "${YELLOW}[3/4]${NC} ${CYAN}Running BDD tests...${NC}"
echo -e "${BLUE}Command:${NC} $TEST_CMD"
echo ""

# TEAM-111: Create test output file (avoid temp files that might get lost)
TEST_OUTPUT="$LOG_DIR/test-output-$TIMESTAMP.log"

# Run tests with proper output handling
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${CYAN}                    🧪 TEST EXECUTION START 🧪${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""

cd "$SCRIPT_DIR"

if $QUIET; then
    # Quiet mode: capture to file only, show spinner
    $TEST_CMD > "$TEST_OUTPUT" 2>&1 &
    TEST_PID=$!
    
    # Show progress while tests run
    SPIN='-\|/'
    i=0
    while kill -0 $TEST_PID 2>/dev/null; do
        i=$(( (i+1) %4 ))
        printf "\r${CYAN}⏳ Running tests... ${SPIN:$i:1}${NC}"
        sleep 0.2
    done
    
    # Get exit status
    wait $TEST_PID
    TEST_STATUS=$?
    
    printf "\r${CYAN}⏳ Running tests... Done!${NC}\n"
else
    # LIVE MODE: Show ALL stdout/stderr in real-time AND capture to file
    # TEAM-111: Using tee to show live output while capturing
    echo -e "${GREEN}📺 LIVE OUTPUT MODE - You will see ALL test output below:${NC}"
    echo ""
    
    $TEST_CMD 2>&1 | tee "$TEST_OUTPUT"
    TEST_STATUS=${PIPESTATUS[0]}
fi

# Append to main log file (safe, no pipeline)
cat "$TEST_OUTPUT" >> "$LOG_FILE"

echo ""
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo -e "${CYAN}                     🧪 TEST EXECUTION END 🧪${NC}"
echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
echo ""

# Step 4: Parse and display results
echo -e "${YELLOW}[4/4]${NC} ${CYAN}Parsing test results...${NC}"
echo ""

# TEAM-111: Extract key information from output (avoid pipeline anti-patterns)
# Step 1: Extract to temp files
grep -o "[0-9]* passed" "$TEST_OUTPUT" > "$LOG_DIR/passed.tmp" 2>/dev/null || echo "0 passed" > "$LOG_DIR/passed.tmp"
grep -o "[0-9]* failed" "$TEST_OUTPUT" > "$LOG_DIR/failed.tmp" 2>/dev/null || echo "0 failed" > "$LOG_DIR/failed.tmp"
grep -o "[0-9]* skipped" "$TEST_OUTPUT" > "$LOG_DIR/skipped.tmp" 2>/dev/null || echo "0 skipped" > "$LOG_DIR/skipped.tmp"

# Step 2: Extract numbers from temp files
grep -o "[0-9]*" "$LOG_DIR/passed.tmp" > "$LOG_DIR/passed-num.tmp" 2>/dev/null || echo "0" > "$LOG_DIR/passed-num.tmp"
grep -o "[0-9]*" "$LOG_DIR/failed.tmp" > "$LOG_DIR/failed-num.tmp" 2>/dev/null || echo "0" > "$LOG_DIR/failed-num.tmp"
grep -o "[0-9]*" "$LOG_DIR/skipped.tmp" > "$LOG_DIR/skipped-num.tmp" 2>/dev/null || echo "0" > "$LOG_DIR/skipped-num.tmp"

# Step 3: Read numbers
PASSED=$(head -1 "$LOG_DIR/passed-num.tmp" 2>/dev/null || echo "0")
FAILED=$(head -1 "$LOG_DIR/failed-num.tmp" 2>/dev/null || echo "0")
SKIPPED=$(head -1 "$LOG_DIR/skipped-num.tmp" 2>/dev/null || echo "0")

# Cleanup temp files
rm -f "$LOG_DIR"/{passed,failed,skipped}{,-num}.tmp

# Extract scenario results
echo -e "${CYAN}╔════════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║                        TEST RESULTS                            ║${NC}"
echo -e "${CYAN}╚════════════════════════════════════════════════════════════════╝${NC}"
echo ""

# Show summary
if [[ $TEST_STATUS -eq 0 ]]; then
    echo -e "${GREEN}✅ ALL TESTS PASSED${NC}"
else
    echo -e "${RED}❌ TESTS FAILED${NC}"
fi

echo ""
echo -e "${BLUE}📊 Summary:${NC}"
echo -e "   ${GREEN}✅ Passed:${NC}  $PASSED"
echo -e "   ${RED}❌ Failed:${NC}  $FAILED"
echo -e "   ${YELLOW}⏭️  Skipped:${NC} $SKIPPED"
echo ""

# TEAM-111: Enhanced failure reporting - show ONLY failure details by default
if [[ $FAILED -gt 0 ]]; then
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}                    ❌ FAILURE DETAILS ❌${NC}"
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    # Extract comprehensive failure information (avoid pipeline anti-patterns)
    # Look for common failure patterns in Cucumber/Rust test output
    
    # Pattern 1: "FAILED" lines with context
    grep -B 2 -A 10 "FAILED" "$TEST_OUTPUT" > "$LOG_DIR/failures-full.tmp" 2>/dev/null || true
    
    # Pattern 2: "Error:" lines with context
    grep -B 2 -A 5 "Error:" "$TEST_OUTPUT" >> "$LOG_DIR/failures-full.tmp" 2>/dev/null || true
    
    # Pattern 3: "assertion" failures
    grep -B 2 -A 5 "assertion" "$TEST_OUTPUT" >> "$LOG_DIR/failures-full.tmp" 2>/dev/null || true
    
    # Pattern 4: "panicked at" messages
    grep -B 2 -A 5 "panicked at" "$TEST_OUTPUT" >> "$LOG_DIR/failures-full.tmp" 2>/dev/null || true
    
    # Pattern 5: Stack traces (lines starting with "at ")
    grep "^\s*at " "$TEST_OUTPUT" >> "$LOG_DIR/failures-full.tmp" 2>/dev/null || true
    
    if [[ -s "$LOG_DIR/failures-full.tmp" ]]; then
        cat "$LOG_DIR/failures-full.tmp"
    else
        # Fallback: show last 50 lines of test output
        echo -e "${YELLOW}No specific failure patterns found. Showing last 50 lines of output:${NC}"
        echo ""
        tail -50 "$TEST_OUTPUT"
    fi
    
    rm -f "$LOG_DIR/failures-full.tmp"
    
    echo ""
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    
    # Save detailed failures to dedicated file
    FAILURES_FILE="$LOG_DIR/failures-$TIMESTAMP.txt"
    {
        echo "FAILURE DETAILS - $TIMESTAMP"
        echo "========================================"
        echo ""
        echo "Failed Tests: $FAILED"
        echo "Command: $TEST_CMD"
        echo ""
        echo "========================================"
        echo ""
        grep -B 2 -A 10 "FAILED" "$TEST_OUTPUT" 2>/dev/null || echo "No FAILED markers found"
        echo ""
        echo "========================================"
        echo "Errors:"
        echo "========================================"
        grep -B 2 -A 5 "Error:" "$TEST_OUTPUT" 2>/dev/null || echo "No Error: markers found"
        echo ""
        echo "========================================"
        echo "Panics:"
        echo "========================================"
        grep -B 2 -A 5 "panicked at" "$TEST_OUTPUT" 2>/dev/null || echo "No panics found"
    } > "$FAILURES_FILE"
    
    echo -e "${BLUE}💾 Detailed failures saved to:${NC} $FAILURES_FILE"
    echo ""
    
    # TEAM-111: Generate rerun command for failed tests only
    RERUN_SCRIPT="$LOG_DIR/rerun-failures.sh"
    RERUN_CMD_FILE="$LOG_DIR/rerun-failures-cmd.txt"
    
    # Extract failed test names (avoid pipeline anti-patterns)
    grep "test .* \.\.\. FAILED" "$TEST_OUTPUT" > "$LOG_DIR/failed-tests.tmp" 2>/dev/null || echo "" > "$LOG_DIR/failed-tests.tmp"
    
    if [[ -s "$LOG_DIR/failed-tests.tmp" ]]; then
        # Parse test names from "test module::name ... FAILED" format
        sed 's/test \(.*\) \.\.\. FAILED/\1/' "$LOG_DIR/failed-tests.tmp" > "$LOG_DIR/failed-test-names.tmp"
        
        # Build cargo test command with specific test names
        {
            echo "#!/usr/bin/env bash"
            echo "# Auto-generated script to re-run ONLY failed tests"
            echo "# Generated: $TIMESTAMP"
            echo "# Failed tests: $FAILED"
            echo ""
            echo "set -euo pipefail"
            echo ""
            echo "cd \"$SCRIPT_DIR\""
            echo ""
            echo "# Re-run only the failed tests:"
            
            # Read each failed test name and add to command
            while IFS= read -r test_name; do
                if [[ -n "$test_name" ]]; then
                    echo "cargo test --test cucumber '$test_name' -- --nocapture"
                fi
            done < "$LOG_DIR/failed-test-names.tmp"
        } > "$RERUN_SCRIPT"
        
        chmod +x "$RERUN_SCRIPT"
        
        # Also create a simple command file (for copy-paste)
        {
            echo "# Re-run failed tests from $TIMESTAMP"
            echo "# Copy and paste the command below:"
            echo ""
            echo "cd $SCRIPT_DIR"
            
            # Build single command with all failed tests
            FAILED_TESTS_LIST=$(tr '\n' ' ' < "$LOG_DIR/failed-test-names.tmp" | sed 's/ $//')
            if [[ -n "$FAILED_TESTS_LIST" ]]; then
                echo "cargo test --test cucumber $FAILED_TESTS_LIST -- --nocapture"
            fi
        } > "$RERUN_CMD_FILE"
        
        rm -f "$LOG_DIR/failed-tests.tmp" "$LOG_DIR/failed-test-names.tmp"
        
        echo -e "${GREEN}🔄 Rerun script generated:${NC}"
        echo -e "   ${CYAN}Executable:${NC}  $RERUN_SCRIPT"
        echo -e "   ${CYAN}Command:${NC}     $RERUN_CMD_FILE"
        echo ""
        echo -e "${YELLOW}💡 To re-run ONLY the failed tests:${NC}"
        echo -e "   ${GREEN}$RERUN_SCRIPT${NC}"
        echo -e "   ${BLUE}or${NC}"
        echo -e "   ${GREEN}bash $RERUN_SCRIPT${NC}"
        echo ""
    else
        echo -e "${YELLOW}⚠️  Could not extract test names for rerun (check output format)${NC}"
        echo ""
    fi
fi

# Show compilation warnings summary
# TEAM-111: Avoid pipeline anti-patterns
grep "^warning:" "$LOG_FILE" > "$LOG_DIR/warnings.tmp" 2>/dev/null || echo "" > "$LOG_DIR/warnings.tmp"
WARNINGS=$(wc -l < "$LOG_DIR/warnings.tmp" 2>/dev/null || echo "0")
rm -f "$LOG_DIR/warnings.tmp"

if [[ $WARNINGS -gt 0 ]]; then
    echo -e "${YELLOW}⚠️  Compilation warnings: $WARNINGS${NC}"
    echo -e "   ${BLUE}(Check $COMPILE_LOG for details)${NC}"
    echo ""
fi

# Save results summary
{
    echo "BDD Test Results - $TIMESTAMP"
    echo "================================"
    echo ""
    echo "Command: $TEST_CMD"
    echo "Status: $([ $TEST_STATUS -eq 0 ] && echo 'PASSED' || echo 'FAILED')"
    echo ""
    echo "Summary:"
    echo "  Passed:  $PASSED"
    echo "  Failed:  $FAILED"
    echo "  Skipped: $SKIPPED"
    echo ""
    echo "Full log: $LOG_FILE"
} > "$RESULTS_FILE"

# Show file locations
echo -e "${BLUE}📁 Output Files:${NC}"
echo -e "   ${CYAN}Summary:${NC}      $RESULTS_FILE"
if [[ $FAILED -gt 0 ]]; then
    echo -e "   ${RED}Failures:${NC}     $FAILURES_FILE  ${YELLOW}⭐ START HERE${NC}"
    if [[ -f "$RERUN_SCRIPT" ]]; then
        echo -e "   ${GREEN}Rerun Script:${NC} $RERUN_SCRIPT  ${YELLOW}🔄 EXECUTABLE${NC}"
        echo -e "   ${GREEN}Rerun Cmd:${NC}    $RERUN_CMD_FILE  ${YELLOW}📋 COPY-PASTE${NC}"
    fi
fi
echo -e "   ${CYAN}Test Output:${NC}  $TEST_OUTPUT"
echo -e "   ${CYAN}Compile Log:${NC}  $COMPILE_LOG"
echo -e "   ${CYAN}Full Log:${NC}     $LOG_FILE"
echo ""

# Show quick access commands
echo -e "${BLUE}💡 Quick Commands (respecting engineering-rules.md):${NC}"
if [[ $FAILED -gt 0 ]]; then
    echo -e "   ${RED}View failures:${NC}   less $FAILURES_FILE  ${YELLOW}⭐ DEBUG${NC}"
    if [[ -f "$RERUN_SCRIPT" ]]; then
        echo -e "   ${GREEN}Rerun failed:${NC}    $RERUN_SCRIPT  ${YELLOW}🔄 FIX & RETRY${NC}"
    fi
fi
echo -e "   ${CYAN}View summary:${NC}    cat $RESULTS_FILE"
echo -e "   ${CYAN}View test log:${NC}   less $TEST_OUTPUT"
echo -e "   ${CYAN}View full log:${NC}   less $LOG_FILE"
echo ""

# Exit with test status
if [[ $TEST_STATUS -eq 0 ]]; then
    echo -e "${GREEN}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║                    ✅ SUCCESS ✅                               ║${NC}"
    echo -e "${GREEN}╚════════════════════════════════════════════════════════════════╝${NC}"
    exit 0
else
    echo -e "${RED}╔════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${RED}║                    ❌ FAILED ❌                                ║${NC}"
    echo -e "${RED}╚════════════════════════════════════════════════════════════════╝${NC}"
    exit 1
fi
