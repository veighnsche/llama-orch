# Architecture V3 Proposal: Fundamental Redesign

**Date**: 2025-10-02  
**Status**: üîµ PROPOSED  
**Risk Level**: HIGH (Breaking changes)  
**Justification**: We're v0.x - now is the time for bold fixes

---

## The Real Problem

The current V2 architecture has a **fundamental flaw**:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ cargo test  ‚îÇ ‚îÄ‚îÄstdout‚îÄ‚îÄ> Warnings, compilation messages
‚îÇ             ‚îÇ ‚îÄ‚îÄstderr‚îÄ‚îÄ> Test output (what we need!)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Parser    ‚îÇ ‚îÄ‚îÄ> Tries to extract tests from wrong stream
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Formatters ‚îÇ ‚îÄ‚îÄ> Generate garbage for empty data
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**But the real issue isn't just stdout vs stderr...**

## The Deeper Problem: We're Fighting Cargo

We're trying to:
1. Run `cargo test` as a subprocess
2. Capture its output
3. Parse human-readable text
4. Hope the format doesn't change
5. Extract metadata from... nowhere (it's not in the output!)

**This is fundamentally fragile.**

---

## V3 Architecture: Use Cargo's Own Tools

### Core Insight

**Cargo already has everything we need:**
- `cargo test -- --format json` - Structured test output
- `libtest-mimic` - Test harness we can hook into
- `cargo metadata` - Crate information
- Test source code - Where metadata annotations live

### New Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    V3 ARCHITECTURE                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Test Harness   ‚îÇ ‚Üê We control this (custom test runner)
‚îÇ  (libtest hook) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îú‚îÄ‚îÄ> Capture test events in real-time
         ‚îú‚îÄ‚îÄ> Extract metadata from test attributes
         ‚îú‚îÄ‚îÄ> Write NDJSON as tests run
         ‚îî‚îÄ‚îÄ> Generate reports after completion
              
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Source Parser   ‚îÇ ‚Üê Parse Rust source for @annotations
‚îÇ (syn crate)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îî‚îÄ‚îÄ> Extract metadata from doc comments
              Build metadata index before tests run

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ JSON Output     ‚îÇ ‚Üê Use cargo test --format json
‚îÇ (cargo native)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îî‚îÄ‚îÄ> Structured, stable format
              No regex parsing needed
```

---

## Proposed Changes

### Change 1: Custom Test Harness (MAJOR)

**Current**: Run `cargo test` as subprocess, parse output

**Proposed**: Hook into the test harness itself

```rust
// In proof-bundle/src/harness/mod.rs
use libtest_mimic::{Arguments, Trial, Conclusion};

pub fn run_with_proof_bundle<F>(tests: Vec<Trial>, setup: F) 
where 
    F: FnOnce() -> ProofBundle
{
    let pb = setup();
    
    // Hook into test execution
    let args = Arguments::from_args();
    
    // Run tests with our wrapper
    for test in tests {
        let start = Instant::now();
        let result = test.run();
        let duration = start.elapsed();
        
        // Write to proof bundle in real-time
        pb.record_test(TestResult {
            name: test.name,
            status: match result {
                Conclusion::Passed => TestStatus::Passed,
                Conclusion::Failed { .. } => TestStatus::Failed,
                Conclusion::Ignored => TestStatus::Ignored,
            },
            duration_secs: duration.as_secs_f64(),
            // Metadata extracted from source
            metadata: METADATA_INDEX.get(test.name),
        });
    }
    
    // Generate reports after all tests
    pb.finalize();
}
```

**Usage in test crates**:
```rust
// In any crate's tests/integration_test.rs
use proof_bundle::harness::run_with_proof_bundle;

#[test]
fn my_test() {
    // Test code
}

// Auto-generated by proc macro
proof_bundle::generate_bundle! {
    mode = UnitFast,
    tests = [my_test, other_test, ...]
}
```

### Change 2: Source Code Metadata Extraction (MAJOR)

**Current**: No metadata extraction (annotations are just comments)

**Proposed**: Parse source files to extract metadata

```rust
// In proof-bundle/src/metadata/extractor.rs
use syn::{File, Item, ItemFn};

pub fn extract_metadata_from_source(crate_root: &Path) -> HashMap<String, TestMetadata> {
    let mut index = HashMap::new();
    
    // Find all test files
    for entry in glob("src/**/*.rs").chain(glob("tests/**/*.rs")) {
        let content = fs::read_to_string(entry)?;
        let ast = syn::parse_file(&content)?;
        
        // Find test functions
        for item in ast.items {
            if let Item::Fn(func) = item {
                if has_test_attribute(&func) {
                    // Extract doc comments
                    let metadata = parse_doc_comments(&func.attrs);
                    index.insert(func.sig.ident.to_string(), metadata);
                }
            }
        }
    }
    
    index
}

fn parse_doc_comments(attrs: &[Attribute]) -> TestMetadata {
    let mut metadata = TestMetadata::default();
    
    for attr in attrs {
        if attr.path.is_ident("doc") {
            let doc = attr.tokens.to_string();
            // Parse @priority: critical, etc.
            metadata.merge(parse_annotations(&doc));
        }
    }
    
    metadata
}
```

**Result**: Metadata is **actually extracted** from source code, not lost!

### Change 3: Use Cargo JSON Output (MEDIUM)

**Current**: Parse human-readable text with regex

**Proposed**: Use `cargo test -- --format json`

```rust
// In proof-bundle/src/runners/cargo_json.rs
use serde::Deserialize;

#[derive(Deserialize)]
#[serde(tag = "type")]
enum TestEvent {
    #[serde(rename = "test")]
    Test {
        name: String,
        event: TestEventType,
    },
    #[serde(rename = "suite")]
    Suite {
        event: String,
        passed: usize,
        failed: usize,
    },
}

pub fn run_tests_json(package: &str) -> Result<TestSummary> {
    let output = Command::new("cargo")
        .args(&["test", "--package", package, "--", "--format", "json"])
        .output()?;
    
    let mut tests = Vec::new();
    
    // Parse JSON lines
    for line in String::from_utf8_lossy(&output.stdout).lines() {
        let event: TestEvent = serde_json::from_str(line)?;
        match event {
            TestEvent::Test { name, event } => {
                tests.push(TestResult {
                    name,
                    status: event.into(),
                    // ...
                });
            }
            _ => {}
        }
    }
    
    Ok(TestSummary { tests, ... })
}
```

**Benefits**:
- ‚úÖ Structured data (no regex)
- ‚úÖ Stable format (cargo guarantees it)
- ‚úÖ More information (timing, stdout, stderr per test)

### Change 4: Proc Macro for Zero-Boilerplate (OPTIONAL)

**Current**: Manual API calls

**Proposed**: Proc macro generates everything

```rust
// In any crate
#[proof_bundle::generate]
mod tests {
    /// @priority: critical
    /// @spec: ORCH-1234
    #[test]
    fn test_something() {
        assert!(true);
    }
}

// Expands to:
mod tests {
    #[test]
    fn test_something() {
        assert!(true);
    }
    
    // Auto-generated
    #[test]
    #[ignore]
    fn __proof_bundle_generate() {
        proof_bundle::api::generate_for_module(module_path!());
    }
}
```

---

## Migration Path

### Phase 1: Fix V2 (1 hour) - **DO THIS NOW**

```diff
// src/api.rs:136
- let summary = parsers::parse_stable_output(&stdout)
+ let summary = parsers::parse_stable_output(&stderr)
```

**Result**: V2 works for basic cases

### Phase 2: Add JSON Support (1 day)

- Implement `cargo test --format json` parser
- Keep regex parser as fallback
- Add feature flag: `json-output`

**Result**: More reliable parsing

### Phase 3: Source Metadata Extraction (2 days)

- Add `syn` dependency
- Implement source code parser
- Build metadata index at compile time
- Merge with test results

**Result**: Metadata actually works!

### Phase 4: Custom Test Harness (1 week)

- Create `libtest-mimic` integration
- Hook into test execution
- Real-time proof bundle generation
- Proc macro for ergonomics

**Result**: Zero-boilerplate, bulletproof system

### Phase 5: Deprecate V1/V2 (v1.0.0)

- Mark old APIs as deprecated
- Migration guide
- Remove in v2.0.0

---

## Comparison

### V1 (Current Legacy)

```rust
let pb = ProofBundle::for_type(TestType::Unit)?;
pb.write_markdown("report", "...");
pb.write_json("summary", &summary);
```

**Problems**:
- ‚ùå Too much boilerplate
- ‚ùå No automatic test running
- ‚ùå No metadata extraction

### V2 (Current, Broken)

```rust
api::generate_for_crate("my-crate", Mode::UnitFast)?;
```

**Problems**:
- ‚ùå Parses wrong output stream
- ‚ùå Fragile regex parsing
- ‚ùå No metadata extraction
- ‚ùå Silent failures

### V3 (Proposed)

```rust
// Option A: Explicit
proof_bundle::generate! {
    package = "my-crate",
    mode = UnitFast,
}

// Option B: Proc macro (zero-boilerplate)
#[proof_bundle::generate]
mod tests {
    #[test]
    fn my_test() { }
}

// Option C: Test harness hook
proof_bundle::harness::run_with_proof_bundle(tests, || {
    ProofBundle::new(Mode::UnitFast)
});
```

**Benefits**:
- ‚úÖ Reliable (uses cargo's own tools)
- ‚úÖ Metadata extraction works
- ‚úÖ Real-time test recording
- ‚úÖ Structured data (JSON)
- ‚úÖ Fail-fast validation
- ‚úÖ Zero or minimal boilerplate

---

## Technical Details

### Metadata Extraction Algorithm

```
1. At build time (build.rs):
   ‚îú‚îÄ> Find all test files (src/**/*.rs, tests/**/*.rs)
   ‚îú‚îÄ> Parse with syn
   ‚îú‚îÄ> Extract #[test] functions
   ‚îú‚îÄ> Parse doc comments for @annotations
   ‚îî‚îÄ> Generate metadata index (metadata_index.json)

2. At test time:
   ‚îú‚îÄ> Load metadata index
   ‚îú‚îÄ> Run tests with custom harness
   ‚îú‚îÄ> Match test name ‚Üí metadata
   ‚îú‚îÄ> Record results with metadata
   ‚îî‚îÄ> Generate reports

3. Reports include:
   ‚îú‚îÄ> Test results (from harness)
   ‚îú‚îÄ> Metadata (from source)
   ‚îú‚îÄ> Timing (from harness)
   ‚îî‚îÄ> Output (from harness)
```

### JSON Test Format (Cargo Native)

```json
{"type":"suite","event":"started","test_count":43}
{"type":"test","event":"started","name":"test_foo"}
{"type":"test","name":"test_foo","event":"ok","exec_time":0.001}
{"type":"test","event":"started","name":"test_bar"}
{"type":"test","name":"test_bar","event":"failed","stdout":"assertion failed"}
{"type":"suite","event":"ok","passed":42,"failed":1}
```

**Benefits**:
- Structured, parseable
- Includes timing per test
- Includes stdout/stderr per test
- Stable format (cargo maintains it)

---

## Risk Assessment

### High Risk Items

1. **Custom test harness** - Major change to how tests run
   - Mitigation: Keep V2 as fallback
   - Testing: Extensive integration tests

2. **Source parsing** - Build-time dependency on `syn`
   - Mitigation: Make it optional (feature flag)
   - Testing: Parse all existing test files

3. **Breaking changes** - V3 API different from V2
   - Mitigation: We're v0.x, breaking changes allowed
   - Migration: Provide migration guide

### Medium Risk Items

1. **JSON parsing** - Depends on cargo's format
   - Mitigation: Cargo guarantees stability
   - Fallback: Keep regex parser

2. **Proc macros** - Complex to implement
   - Mitigation: Make it optional
   - Alternative: Explicit API works fine

### Low Risk Items

1. **Formatters** - No changes needed
2. **Templates** - No changes needed
3. **File structure** - No changes needed

---

## Decision Points

### Must Decide Now

1. **Fix V2 immediately?** 
   - ‚úÖ YES - 1 line change, unblocks everything
   - Do this regardless of V3 decision

2. **Pursue V3 architecture?**
   - ‚úÖ RECOMMENDED - Fixes fundamental issues
   - We're v0.x, this is the time

3. **Timeline?**
   - Phase 1 (V2 fix): Today (1 hour)
   - Phase 2 (JSON): This week (1 day)
   - Phase 3 (Metadata): Next week (2 days)
   - Phase 4 (Harness): Sprint 2 (1 week)

### Can Decide Later

1. Proc macro vs explicit API
2. Feature flags vs always-on
3. V1 deprecation timeline

---

## Recommendation

### Immediate Action (Today)

1. **Fix V2 bug** - Change stdout to stderr
2. **Add validation** - Fail if 0 tests found
3. **Add JSON parser** - Use cargo's native format
4. **Test thoroughly** - Verify 43 tests captured

**Time**: 2-3 hours  
**Risk**: LOW  
**Impact**: V2 API works

### Short Term (This Week)

1. **Implement source metadata extraction**
2. **Build metadata index at compile time**
3. **Merge metadata with test results**
4. **Generate beautiful reports with real metadata**

**Time**: 2 days  
**Risk**: MEDIUM  
**Impact**: Metadata actually works!

### Medium Term (Next Sprint)

1. **Custom test harness with libtest-mimic**
2. **Real-time proof bundle generation**
3. **Proc macro for zero-boilerplate**
4. **Comprehensive integration tests**

**Time**: 1 week  
**Risk**: HIGH  
**Impact**: Production-ready, bulletproof system

---

## Success Criteria

### V3 Must Achieve

1. ‚úÖ **Reliability**: No silent failures, fail-fast validation
2. ‚úÖ **Metadata**: Actually extract and use @annotations
3. ‚úÖ **Ergonomics**: Zero or one-line usage
4. ‚úÖ **Accuracy**: Capture all tests, all metadata
5. ‚úÖ **Performance**: Real-time recording, fast reports
6. ‚úÖ **Stability**: Use cargo's stable APIs, not fragile parsing

### Metrics

- **Test capture rate**: 100% (currently 0%)
- **Metadata extraction**: 100% (currently 0%)
- **Silent failures**: 0 (currently 100%)
- **Boilerplate**: 0-1 lines (currently 1 line but broken)
- **Report quality**: Beautiful, accurate, useful

---

## Conclusion

**The V2 bug reveals a fundamental architectural problem.**

We can:
1. ‚ùå **Band-aid fix**: Change stdout‚Üístderr, still fragile
2. ‚úÖ **Proper fix**: Redesign with cargo's native tools

**Recommendation**: Do both.
- Fix V2 today (unblock current work)
- Build V3 this sprint (fix it properly)

We're v0.x - **this is exactly the time for bold architectural changes.**

**The question isn't "should we make major changes?"**  
**The question is "what's the right architecture for the next 5 years?"**

V3 is that architecture.
