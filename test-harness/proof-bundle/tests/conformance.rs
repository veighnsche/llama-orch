use proof_bundle::{ProofBundle, TestType};
use serial_test::serial;
use std::env;
use std::fs;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use tempfile::TempDir;

fn set_env(k: &str, v: &str) {
    env::set_var(k, v);
}

fn unset_env(k: &str) {
    env::remove_var(k);
}

fn read_to_string(p: impl Into<PathBuf>) -> String {
    fs::read_to_string(p.into()).unwrap()
}

#[test]
#[serial]
fn pbv_2001_creates_dir_under_default_base() {
    // Control base path via LLORCH_PROOF_DIR to avoid CWD dependencies
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUNID-A");

    let pb = ProofBundle::for_type(TestType::Unit).unwrap();
    assert!(pb.root().ends_with("unit/RUNID-A"), "root = {}", pb.root().display());
    assert!(pb.root().exists());

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn pbv_2002_honors_env_overrides() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUNID-XYZ");

    let pb = ProofBundle::for_type(TestType::Integration).unwrap();
    assert!(pb.root().ends_with("integration/RUNID-XYZ"));
    assert!(pb.root().starts_with(tmp.path()));

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn pbv_2003_append_ndjson_appends_lines() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN1");

    let pb = ProofBundle::for_type(TestType::Contract).unwrap();
    pb.append_ndjson("events", &serde_json::json!({"a":1})).unwrap();
    pb.append_ndjson("events", &serde_json::json!({"b":2})).unwrap();

    let file = pb.root().join("events.ndjson");
    let f = fs::File::open(&file).unwrap();
    let lines: Vec<_> = BufReader::new(f).lines().map(|l| l.unwrap()).collect();
    // PB-1012: first record should be a metadata record
    assert_eq!(lines.len(), 3);
    assert!(lines[0].contains("\"_meta\":\"proof_bundle\""));
    assert_eq!(lines[1], "{\"a\":1}");
    assert_eq!(lines[2], "{\"b\":2}");

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn pbv_2004_write_json_pretty_and_overwrite() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN2");

    let pb = ProofBundle::for_type(TestType::Bdd).unwrap();
    pb.write_json("run_config", &serde_json::json!({"ok": true})).unwrap();
    let s1 = read_to_string(pb.root().join("run_config.json"));
    assert!(s1.contains("\n")); // pretty printed
    pb.write_json("run_config", &serde_json::json!({"ok": false})).unwrap();
    let s2 = read_to_string(pb.root().join("run_config.json"));
    assert!(s2.contains("false"));

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn pbv_2005_write_markdown_overwrites() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN3");

    let pb = ProofBundle::for_type(TestType::Determinism).unwrap();
    pb.write_markdown("test_report.md", "# A\n").unwrap();
    pb.write_markdown("test_report.md", "# B\n").unwrap();
    let s = read_to_string(pb.root().join("test_report.md"));
    // PB-1012: header must be first line; overwrite should reflect new body on second line
    let mut it = s.lines();
    assert_eq!(it.next().unwrap(), "# AUTOGENERATED: Proof Bundle");
    assert_eq!(it.next().unwrap(), "# B");

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn pbv_2006_seeds_record_appends() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN4");

    let pb = ProofBundle::for_type(TestType::Smoke).unwrap();
    pb.seeds().record(41).unwrap();
    pb.seeds().record(42).unwrap();

    let s = read_to_string(pb.root().join("seeds.txt"));
    assert!(s.contains("seed=41"));
    assert!(s.contains("seed=42"));

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
fn pbv_2007_testtype_mapping_exact() {
    assert_eq!(TestType::Unit.as_dir(), "unit");
    assert_eq!(TestType::Integration.as_dir(), "integration");
    assert_eq!(TestType::Contract.as_dir(), "contract");
    assert_eq!(TestType::Bdd.as_dir(), "bdd");
    assert_eq!(TestType::Determinism.as_dir(), "determinism");
    assert_eq!(TestType::Smoke.as_dir(), "home-profile-smoke");
    assert_eq!(TestType::E2eHaiku.as_dir(), "e2e-haiku");
}

#[test]
#[serial]
fn helpers_markdown_with_header_and_meta_writers() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN-H");

    let pb = ProofBundle::for_type(TestType::Unit).unwrap();
    pb.write_markdown_with_header("test_report.md", "# OK\n").unwrap();
    let s = read_to_string(pb.root().join("test_report.md"));
    assert!(s.starts_with("# AUTOGENERATED: Proof Bundle\n"));

    pb.write_json_with_meta("run_config", &serde_json::json!({"ok": true})).unwrap();
    assert!(pb.root().join("run_config.json").exists());
    assert!(pb.root().join("run_config.json.meta").exists());

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}

#[test]
#[serial]
fn helpers_append_ndjson_autogen_meta_once() {
    let tmp = TempDir::new().unwrap();
    set_env("LLORCH_PROOF_DIR", tmp.path().to_str().unwrap());
    set_env("LLORCH_RUN_ID", "RUN-I");

    let pb = ProofBundle::for_type(TestType::Integration).unwrap();
    pb.append_ndjson_autogen_meta("stream").unwrap();
    pb.append_ndjson("stream", &serde_json::json!({"event":"started"})).unwrap();
    pb.append_ndjson_autogen_meta("stream").unwrap(); // should not duplicate

    let file = pb.root().join("stream.ndjson");
    let f = fs::File::open(&file).unwrap();
    let lines: Vec<_> = BufReader::new(f).lines().map(|l| l.unwrap()).collect();
    assert!(lines.first().unwrap().contains("\"_meta\":\"proof_bundle\""));
    assert_eq!(lines.len(), 2);

    unset_env("LLORCH_PROOF_DIR");
    unset_env("LLORCH_RUN_ID");
}
