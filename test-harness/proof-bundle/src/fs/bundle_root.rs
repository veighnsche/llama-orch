use crate::env::{proof_base_dir, resolve_run_id};
use crate::policy::headers::{ensure_text_header_write, ndjson_meta_value, TEXT_HEADER};
use crate::types::{sanitize_name, TestType};
use crate::util::ensure_ext;
use crate::writers::Writers;
use anyhow::{Context, Result};
use serde::Serialize;
use std::fs::{self, File, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};

/// A handle to a proof bundle directory for a specific test type and run.
#[derive(Clone, Debug)]
pub struct ProofBundle {
    pub(crate) root: PathBuf,
}

impl ProofBundle {
    /// Create or open the proof bundle directory for a given test type.
    /// 
    /// **Cleanup Policy**: Before creating the new bundle, this method automatically
    /// removes all existing bundles for this test type to keep only the latest one.
    pub fn for_type(test_type: TestType) -> Result<Self> {
        let base = proof_base_dir()?;
        let run_id = resolve_run_id();
        let type_dir = base.join(test_type.as_dir());
        
        // CLEANUP: Remove all existing bundles for this test type before creating new one
        if type_dir.exists() {
            if let Ok(entries) = fs::read_dir(&type_dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.is_dir() {
                        // Remove old bundle directory
                        if let Err(e) = fs::remove_dir_all(&path) {
                            eprintln!(
                                "Warning: Failed to remove old proof bundle {}: {}",
                                path.display(),
                                e
                            );
                        }
                    }
                }
            }
        }
        
        // Create new bundle directory
        let root = type_dir.join(run_id);
        fs::create_dir_all(&root)
            .with_context(|| format!("creating proof bundle dir: {}", root.display()))?;
        Ok(Self { root })
    }

    /// Root folder of this bundle.
    pub fn root(&self) -> &Path {
        &self.root
    }

    /// Expose the writers facade for advanced use.
    pub fn writers(&self) -> Writers<'_> {
        Writers { pb: self }
    }

    /// Ensure a subdirectory exists and return its path.
    pub fn ensure_dir<S: AsRef<str>>(&self, sub: S) -> Result<PathBuf> {
        let sub = sanitize_name(sub)?;
        let p = self.root.join(&sub);
        fs::create_dir_all(&p).with_context(|| format!("creating subdir: {}", p.display()))?;
        Ok(p)
    }

    /// Append a JSON value as a single NDJSON line to `<name>.ndjson`.
    /// If the file is empty or does not exist, write a metadata record first.
    pub fn append_ndjson<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let name = sanitize_name(name)?;
        let path = ensure_ext(self.root.join(&name), "ndjson");
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("create parent: {}", parent.display()))?;
        }
        // Ensure metadata record exists first
        let exists_and_nonempty =
            path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            let mut meta = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&path)
                .with_context(|| format!("open for append: {}", path.display()))?;
            let line = serde_json::to_string(&ndjson_meta_value())?;
            writeln!(meta, "{}", line)?;
        }
        let mut f = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&path)
            .with_context(|| format!("open for append: {}", path.display()))?;
        let line = serde_json::to_string(value)?;
        writeln!(f, "{}", line)?;
        Ok(())
    }

    /// Write a JSON file, overwriting if it exists, and create a sibling `.meta` header file.
    pub fn write_json<T: Serialize, N: AsRef<str>>(&self, name: N, value: &T) -> Result<()> {
        let name = sanitize_name(name)?;
        let path = ensure_ext(self.root.join(&name), "json");
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("create parent: {}", parent.display()))?;
        }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        let s = serde_json::to_string_pretty(value)?;
        f.write_all(s.as_bytes())?;
        // Write sibling .meta to signal autogenerated bundle artifact, alongside the JSON file
        let rel = path.strip_prefix(&self.root).unwrap_or(&path).to_path_buf();
        let meta_rel = rel.with_file_name(format!(
            "{}{}",
            rel.file_name().unwrap().to_string_lossy(),
            ".meta"
        ));
        self.write_markdown(meta_rel.to_string_lossy(), TEXT_HEADER)?;
        Ok(())
    }

    /// Write a Markdown file, overwriting if it exists. Prepends the required header if missing.
    pub fn write_markdown<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let name = sanitize_name(name)?;
        let path = self.root.join(&name);
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)
                .with_context(|| format!("create parent: {}", parent.display()))?;
        }
        let mut f = File::create(&path).with_context(|| format!("create: {}", path.display()))?;
        ensure_text_header_write(&mut f, body)?;
        Ok(())
    }

    /// Write a Markdown file with the required autogenerated header.
    pub fn write_markdown_with_header<N: AsRef<str>>(&self, name: N, body: &str) -> Result<()> {
        let mut full = String::from(TEXT_HEADER);
        full.push_str(body);
        self.write_markdown(name, &full)
    }

    /// Access a seeds recorder that appends to `seeds.txt`.
    pub fn seeds(&self) -> super::SeedsRecorder {
        super::SeedsRecorder { path: self.root.join("seeds.txt") }
    }

    /// Ensure the first NDJSON record indicates an autogenerated proof bundle.
    /// If the file already exists and is non-empty, this is a no-op.
    pub fn append_ndjson_autogen_meta<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let name = sanitize_name(name)?;
        let path = ensure_ext(self.root.join(&name), "ndjson");
        let exists_and_nonempty =
            path.exists() && path.metadata().map(|m| m.len() > 0).unwrap_or(false);
        if !exists_and_nonempty {
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)
                    .with_context(|| format!("create parent: {}", parent.display()))?;
            }
            let mut f = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&path)
                .with_context(|| format!("open for append: {}", path.display()))?;
            let line = serde_json::to_string(&ndjson_meta_value())?;
            writeln!(f, "{}", line)?;
        }
        Ok(())
    }

    /// Write a sibling `.meta` file next to a JSON/other artifact with the header line.
    pub fn write_meta_sibling<N: AsRef<str>>(&self, name: N) -> Result<()> {
        let name = sanitize_name(name)?;
        let meta = format!("{}{}", name.as_str(), ".meta");
        self.write_markdown(meta, TEXT_HEADER)
    }

    /// Write JSON (pretty) and emit a sibling `.meta` file with the header line.
    pub fn write_json_with_meta<T: Serialize, N: AsRef<str>>(
        &self,
        name: N,
        value: &T,
    ) -> Result<()> {
        let name = sanitize_name(name)?;
        self.write_json(&name, value)?;
        // Ensure meta is placed next to the .json path (e.g., config/run.json.meta)
        let json_rel = ensure_ext(PathBuf::from(&name), "json");
        let rel_str = json_rel.to_string_lossy().to_string();
        self.write_meta_sibling(rel_str)
    }
    
    /// Capture test results from cargo test
    ///
    /// Returns a builder for configuring which tests to run.
    ///
    /// # Example
    /// ```no_run
    /// use proof_bundle::{ProofBundle, TestType};
    /// 
    /// let pb = ProofBundle::for_type(TestType::Unit)?;
    /// 
    /// let summary = pb.capture_tests("vram-residency")
    ///     .lib()
    ///     .tests()
    ///     .run()?;
    /// 
    /// println!("Captured {} tests ({} passed, {} failed)", 
    ///     summary.total, summary.passed, summary.failed);
    /// # Ok::<(), anyhow::Error>(())
    /// ```
    pub fn capture_tests(&self, package: &str) -> crate::capture::TestCaptureBuilder {
        crate::capture::TestCaptureBuilder::new(self, package)
    }
}
