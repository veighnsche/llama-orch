//! Proof bundle file I/O
//!
//! Simple, clean file writing for proof bundles.

use crate::core::{Mode, TestResult};
use crate::Result;
use std::fs;
use std::path::{Path, PathBuf};

/// Proof bundle writer
pub struct BundleWriter {
    root: PathBuf,
}

impl BundleWriter {
    /// Create a new bundle writer
    ///
    /// Creates directory structure: `.proof_bundle/{mode}/{timestamp}/`
    pub fn new(mode: Mode) -> Result<Self> {
        let timestamp = chrono::Utc::now().timestamp();
        let root = PathBuf::from(".proof_bundle")
            .join(mode.name())
            .join(timestamp.to_string());
        
        fs::create_dir_all(&root)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("create directory {}", root.display()),
                source: e,
            })?;
        
        Ok(Self { root })
    }
    
    /// Write NDJSON file (one JSON object per line)
    pub fn write_ndjson(&self, name: &str, results: &[TestResult]) -> Result<()> {
        let path = self.root.join(format!("{}.ndjson", name));
        let mut content = String::new();
        
        for result in results {
            let json = serde_json::to_string(result)?;
            content.push_str(&json);
            content.push('\n');
        }
        
        fs::write(&path, content)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write NDJSON {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Write JSON file
    pub fn write_json<T: serde::Serialize>(&self, name: &str, data: &T) -> Result<()> {
        let path = self.root.join(format!("{}.json", name));
        let json = serde_json::to_string_pretty(data)?;
        
        fs::write(&path, json)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write JSON {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Write markdown file
    pub fn write_markdown(&self, name: &str, content: &str) -> Result<()> {
        let path = self.root.join(format!("{}.md", name));
        
        // Add autogenerated header
        let mut full_content = String::from("# AUTOGENERATED: Proof Bundle\n");
        full_content.push_str(content);
        
        fs::write(&path, full_content)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write markdown {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Get the root directory path
    pub fn root(&self) -> &Path {
        &self.root
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::{TestSummary, TestResult, TestStatus};
    
    #[test]
    fn test_bundle_writer_creates_directory() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        assert!(writer.root().exists());
        assert!(writer.root().is_dir());
    }
    
    #[test]
    fn test_write_json() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        let summary = TestSummary::default();
        
        writer.write_json("test", &summary).unwrap();
        
        let path = writer.root().join("test.json");
        assert!(path.exists());
    }
    
    #[test]
    fn test_write_markdown() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        
        writer.write_markdown("report", "# Test Report\n\nContent here").unwrap();
        
        let path = writer.root().join("report.md");
        assert!(path.exists());
        
        let content = fs::read_to_string(path).unwrap();
        assert!(content.contains("AUTOGENERATED"));
        assert!(content.contains("Test Report"));
    }
}
