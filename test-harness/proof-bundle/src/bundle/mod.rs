//! Proof bundle file I/O
//!
//! Simple, clean file writing for proof bundles.

use crate::core::{Mode, TestResult};
use crate::Result;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Proof bundle writer
pub struct BundleWriter {
    root: PathBuf,
}

impl BundleWriter {
    /// Create a new bundle writer
    ///
    /// Creates directory structure: `<crate>/.proof_bundle/{mode}/{run_id}/`
    ///
    /// Behavior:
    /// - Honors LLORCH_PROOF_DIR to override base directory
    /// - Otherwise uses crate-local CARGO_MANIFEST_DIR
    /// - Cleans up any previous run directories for the given mode
    /// - Run ID comes from LLORCH_RUN_ID or `YYYYMMDD-HHMMSS-<gitsha8>`
    pub fn new(mode: Mode) -> Result<Self> {
        // Resolve base directory: LLORCH_PROOF_DIR override or crate-local
        let base_dir = if let Ok(override_dir) = env::var("LLORCH_PROOF_DIR") {
            PathBuf::from(override_dir)
        } else {
            let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap_or_else(|_| ".".to_string());
            PathBuf::from(manifest_dir).join(".proof_bundle")
        };

        // Ensure per-mode directory exists and clean previous runs
        let type_dir = base_dir.join(mode.name());
        if type_dir.exists() {
            if let Ok(entries) = fs::read_dir(&type_dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    // Remove only directories (previous run ids)
                    if path.is_dir() {
                        let _ = fs::remove_dir_all(&path);
                    }
                }
            }
        }

        // Resolve run id
        let run_id = if let Ok(explicit) = env::var("LLORCH_RUN_ID") {
            explicit
        } else {
            let ts = chrono::Utc::now().format("%Y%m%d-%H%M%S");
            let sha = short_git_sha().unwrap_or_else(|| "nogit".to_string());
            format!("{}-{}", ts, sha)
        };

        let root = type_dir.join(run_id);

        fs::create_dir_all(&root)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("create directory {}", root.display()),
                source: e,
            })?;

        Ok(Self { root })
    }
    
    /// Write NDJSON file (one JSON object per line)
    pub fn write_ndjson(&self, name: &str, results: &[TestResult]) -> Result<()> {
        let path = self.root.join(format!("{}.ndjson", name));
        let mut content = String::new();
        // Metadata header record
        let header = serde_json::json!({
            "_meta": "proof_bundle",
            "_note": "autogenerated",
            "_timestamp": chrono::Utc::now().to_rfc3339(),
        });
        content.push_str(&serde_json::to_string(&header)?);
        content.push('\n');

        for result in results {
            let json = serde_json::to_string(result)?;
            content.push_str(&json);
            content.push('\n');
        }
        
        fs::write(&path, content)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write NDJSON {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Write JSON file
    pub fn write_json<T: serde::Serialize>(&self, name: &str, data: &T) -> Result<()> {
        let path = self.root.join(format!("{}.json", name));
        let json = serde_json::to_string_pretty(data)?;
        
        fs::write(&path, json)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write JSON {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Write markdown file
    pub fn write_markdown(&self, name: &str, content: &str) -> Result<()> {
        let path = self.root.join(format!("{}.md", name));
        
        // Add autogenerated header
        let mut full_content = String::from("# AUTOGENERATED: Proof Bundle\n");
        full_content.push_str(content);
        
        fs::write(&path, full_content)
            .map_err(|e| crate::core::ProofBundleError::Io {
                operation: format!("write markdown {}", path.display()),
                source: e,
            })?;
        
        Ok(())
    }
    
    /// Get the root directory path
    pub fn root(&self) -> &Path {
        &self.root
    }
}

/// Try to get a short git SHA (8 chars); returns None if not available
fn short_git_sha() -> Option<String> {
    let output = Command::new("git").args(["rev-parse", "--short=8", "HEAD"]).output().ok()?;
    if !output.status.success() { return None; }
    let sha = String::from_utf8_lossy(&output.stdout).trim().to_string();
    if sha.is_empty() { None } else { Some(sha) }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::{TestSummary, TestResult, TestStatus};
    
    /// @priority: critical
    /// @spec: PB-001
    /// @team: proof-bundle
    /// @tags: unit, bundle, file-io, crate-local
    #[test]
    fn test_bundle_writer_creates_directory() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        assert!(writer.root().exists());
        assert!(writer.root().is_dir());
    }
    
    /// @priority: critical
    /// @spec: PB-1004
    /// @team: proof-bundle
    /// @tags: unit, bundle, json, file-io
    #[test]
    fn test_write_json() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        let summary = TestSummary::default();
        
        writer.write_json("test", &summary).unwrap();
        
        let path = writer.root().join("test.json");
        assert!(path.exists());
    }
    
    /// @priority: critical
    /// @spec: PB-1012
    /// @team: proof-bundle
    /// @tags: unit, bundle, markdown, autogenerated-header
    #[test]
    fn test_write_markdown() {
        let writer = BundleWriter::new(Mode::UnitFast).unwrap();
        
        writer.write_markdown("report", "# Test Report\n\nContent here").unwrap();
        
        let path = writer.root().join("report.md");
        assert!(path.exists());
        
        let content = fs::read_to_string(path).unwrap();
        assert!(content.contains("AUTOGENERATED"));
        assert!(content.contains("Test Report"));
    }
}
